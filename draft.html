<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="Icons/Grain.webp">
    <title>Agricola Draft Tool</title>
    <link rel="stylesheet" href="draft.css">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="card-image-list.js"></script>
</head>
<body>
    <div id="root">
        <div class="loading">Loading draft tool...</div>
    </div>

    <script type="text/babel">
const { useState, useEffect, useRef, useCallback, useMemo } = React;

// ─── Constants ──────────────────────────────────────────────────────
const HAND_SIZE_BY_ROUND = { 1: 10, 2: 9, 3: 8, 4: 7, 5: 6, 6: 5, 7: 4 };

// Rounds 5-7 get back hands from rounds 1-3 (4-player rotation)
const RETURNING_HAND_SOURCE = { 5: 1, 6: 2, 7: 3 };

const SORT_OPTIONS = [
    { key: 'rank', label: 'Rank', getValue: c => c.rank, ascending: true },
    { key: 'adp', label: 'ADP', getValue: c => parseFloat(c.adp) || 999, ascending: true },
    { key: 'elo_per_play', label: 'Elo/Play', getValue: c => parseFloat(c.elo_per_play) || 0, ascending: false },
    { key: 'value', label: 'Draft Value', getValue: c => parseFloat(c.value) || 0, ascending: false },
];

const STORAGE_KEY = 'agricola-draft-state';

// ─── Image resolution (shared with index.html) ─────────────────────
const cardImageMap = {};

function normalizeForMatch(str) {
    return str.toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/[\s\-'\.]/g, '');
}

CARD_IMAGE_LIST.forEach(filename => {
    const nameWithoutExt = filename.replace(/\.png$/, '');
    const normalized = normalizeForMatch(nameWithoutExt);
    cardImageMap[normalized] = filename;
});

function getCardImagePath(cardName) {
    const normalized = normalizeForMatch(cardName);
    const filename = cardImageMap[normalized];
    return filename ? `card-images/${filename}` : null;
}

// ─── Pass number helper ─────────────────────────────────────────────
function getPassNumber(round) {
    return parseInt(round) <= 4 ? 1 : 2;
}

// ─── Hand number helper (rounds 5-7 map back to hands 1-3) ─────────
function getHandNumber(round) {
    const r = parseInt(round);
    return RETURNING_HAND_SOURCE[r] || r;
}

// Hand grouping: which rounds belong to each hand
const HAND_GROUPS = [
    { handNum: 1, pass1Round: 1, pass2Round: 5 },
    { handNum: 2, pass1Round: 2, pass2Round: 6 },
    { handNum: 3, pass1Round: 3, pass2Round: 7 },
    { handNum: 4, pass1Round: 4, pass2Round: null },
];

// ─── localStorage helpers ───────────────────────────────────────────
function loadSavedState() {
    try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
    } catch { return null; }
}

function saveState(state) {
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch { /* ignore quota errors */ }
}

function clearSavedState() {
    localStorage.removeItem(STORAGE_KEY);
}

// ─── CardSearch Component ───────────────────────────────────────────
function CardSearch({ cards, onAddCard, allUsedCardNames }) {
    const [query, setQuery] = useState('');
    const [highlightIndex, setHighlightIndex] = useState(-1);
    const inputRef = useRef(null);
    const suggestionsRef = useRef(null);

    const matches = useMemo(() => {
        if (query.length === 0) return [];
        const q = query.toLowerCase();
        return cards
            .filter(card =>
                card.name.toLowerCase().includes(q) &&
                !allUsedCardNames.has(card.name)
            )
            .slice(0, 10);
    }, [query, cards, allUsedCardNames]);

    const selectCard = useCallback((card) => {
        onAddCard(card);
        setQuery('');
        setHighlightIndex(-1);
        setTimeout(() => inputRef.current?.focus(), 0);
    }, [onAddCard]);

    const handleKeyDown = useCallback((e) => {
        if (matches.length === 0) return;
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            setHighlightIndex(prev => Math.min(prev + 1, matches.length - 1));
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            setHighlightIndex(prev => Math.max(prev - 1, 0));
        } else if (e.key === 'Enter') {
            e.preventDefault();
            if (highlightIndex >= 0 && highlightIndex < matches.length) {
                selectCard(matches[highlightIndex]);
            } else if (matches.length > 0) {
                selectCard(matches[0]);
            }
        } else if (e.key === 'Escape') {
            setQuery('');
            setHighlightIndex(-1);
        }
    }, [matches, highlightIndex, selectCard]);

    useEffect(() => {
        if (highlightIndex >= 0 && suggestionsRef.current) {
            const items = suggestionsRef.current.querySelectorAll('.suggestion-item');
            if (items[highlightIndex]) {
                items[highlightIndex].scrollIntoView({ block: 'nearest' });
            }
        }
    }, [highlightIndex]);

    return (
        <div className="search-section">
            <div className="search-label">Search for a card to add to this hand</div>
            <input
                ref={inputRef}
                type="text"
                className="search-input"
                placeholder="Type card name..."
                value={query}
                onChange={e => { setQuery(e.target.value); setHighlightIndex(-1); }}
                onKeyDown={handleKeyDown}
                autoComplete="off"
                autoFocus
            />
            {matches.length > 0 && (
                <div className="suggestions active" ref={suggestionsRef}>
                    {matches.map((card, i) => (
                        <div
                            key={card.name}
                            className={`suggestion-item${i === highlightIndex ? ' highlighted' : ''}`}
                            onClick={() => selectCard(card)}
                            onMouseEnter={() => setHighlightIndex(i)}
                        >
                            <span className="suggestion-rank">#{card.rank}</span>
                            <span className="suggestion-name">{card.name}</span>
                            <span className="suggestion-type">{card.type === 'Occupation' ? 'Occ' : 'Minor'}</span>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
}

// ─── HandColumn Component ───────────────────────────────────────────
function HandColumn({ title, cards, expectedCount, sortKey, onRemoveCard, onSelectCard, selectedCardName, showRemove, fadedCardNames, onToggleFaded }) {
    const count = cards.length;
    const fadedSet = useMemo(() => new Set(fadedCardNames || []), [fadedCardNames]);
    const availableCount = cards.filter(c => !fadedSet.has(c.name)).length;

    const sortOption = SORT_OPTIONS.find(s => s.key === sortKey) || SORT_OPTIONS[0];
    const sortedCards = useMemo(() => {
        return [...cards].sort((a, b) => {
            const aVal = sortOption.getValue(a);
            const bVal = sortOption.getValue(b);
            if (aVal < bVal) return sortOption.ascending ? -1 : 1;
            if (aVal > bVal) return sortOption.ascending ? 1 : -1;
            return 0;
        });
    }, [cards, sortOption]);

    return (
        <div className="hand-column">
            <div className="column-header">
                <span>{title}</span>
                <span className={`card-count${count === expectedCount ? ' complete' : ''}`}>
                    {fadedCardNames ? `${availableCount} avail` : `${count}/${expectedCount}`}
                </span>
            </div>
            <div className="card-list">
                {sortedCards.length === 0 && (
                    <div className="empty-hand" style={{ padding: '12px', fontSize: '0.85em' }}>
                        No cards added yet
                    </div>
                )}
                {sortedCards.map(card => {
                    const isSelected = card.name === selectedCardName;
                    const isFaded = fadedSet.has(card.name);
                    const handleClick = () => {
                        if (onToggleFaded) {
                            onToggleFaded(card.name);
                        } else if (onSelectCard && !isFaded) {
                            onSelectCard(card.name);
                        }
                    };
                    return (
                        <div
                            key={card.name}
                            className={`card-row${isSelected ? ' selected' : ''}${isFaded ? ' faded' : ''}`}
                            onClick={handleClick}
                        >
                            <span className="card-name">{card.name}</span>
                            <div className="card-stat">
                                <div className="card-stat-label">Rank</div>
                                <div>#{card.rank}</div>
                            </div>
                            <div className="card-stat">
                                <div className="card-stat-label">ADP</div>
                                <div>{card.adp}</div>
                            </div>
                            <div className="card-stat">
                                <div className="card-stat-label">Elo/Play</div>
                                <div>{card.elo_per_play || '—'}</div>
                            </div>
                            <div className="card-stat">
                                <div className="card-stat-label">Value</div>
                                <div>{card.value ? parseFloat(card.value).toFixed(1) : '—'}</div>
                            </div>
                            {showRemove && (
                                <button
                                    className="remove-btn"
                                    onClick={(e) => { e.stopPropagation(); onRemoveCard(card.name); }}
                                    title="Remove card"
                                >
                                    ✕
                                </button>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
}

// ─── PriorHands Component ───────────────────────────────────────────
function PriorHands({ hands, draftedCards, cardMap, currentRound, othersDrafted, onCardClick }) {
    const othersDraftedSet = new Set(othersDrafted || []);

    // Determine which hand groups have at least one completed pass
    const visibleHandGroups = HAND_GROUPS.filter(hg =>
        hands[hg.pass1Round] || (hg.pass2Round && hands[hg.pass2Round])
    );
    if (visibleHandGroups.length === 0) return null;

    const renderMiniCard = (name, round) => {
        const drafted = draftedCards[round] || {};
        const draftedSet = new Set([drafted.occupation, drafted.minor].filter(Boolean));
        const isDrafted = draftedSet.has(name);
        const isOthersTook = othersDraftedSet.has(name);
        const passNum = isDrafted ? getPassNumber(round) : null;

        return (
            <div
                key={name}
                className={`mini-card ${isDrafted ? 'drafted' : isOthersTook ? 'others-took' : 'passed'} clickable`}
                onClick={(e) => onCardClick && onCardClick(name, e)}
            >
                {passNum ? <span className="pick-badge">{passNum}</span> : isOthersTook ? '✗ ' : ''}{name}
            </div>
        );
    };

    return (
        <div className="prior-hands-section">
            <div className="prior-hands-title">Prior Hands</div>
            <div className="prior-hands-grid">
                {visibleHandGroups.map(({ handNum, pass1Round, pass2Round }) => {
                    const pass1Hand = hands[pass1Round] || [];
                    const pass1Drafted = draftedCards[pass1Round] || {};
                    const pass1DraftedSet = new Set([pass1Drafted.occupation, pass1Drafted.minor].filter(Boolean));
                    const hasPass1 = !!hands[pass1Round];

                    const pass2Hand = pass2Round ? (hands[pass2Round] || []) : [];
                    const pass2Drafted = pass2Round ? (draftedCards[pass2Round] || {}) : {};
                    const pass2DraftedSet = new Set([pass2Drafted.occupation, pass2Drafted.minor].filter(Boolean));
                    const hasPass2 = pass2Round && !!hands[pass2Round];

                    // Pass 1 drafted cards (occ + minor)
                    const pass1OccPick = pass1Drafted.occupation;
                    const pass1MinPick = pass1Drafted.minor;

                    // Pass 2 drafted cards (occ + minor)
                    const pass2OccPick = hasPass2 ? pass2Drafted.occupation : null;
                    const pass2MinPick = hasPass2 ? pass2Drafted.minor : null;

                    // Others-took cards from returning hand
                    const othersTookCards = hasPass2
                        ? pass2Hand.filter(n => othersDraftedSet.has(n))
                        : [];

                    // Remaining passed cards: in pass1Hand, not drafted by anyone in either pass, not others-took
                    const allDraftedNames = new Set([
                        ...pass1DraftedSet,
                        ...pass2DraftedSet,
                        ...othersTookCards,
                    ]);

                    // Helper to get the round a card belongs to (for renderMiniCard styling)
                    const othersTookSet = new Set(othersTookCards);
                    const getRoundForCard = (name) => {
                        if (pass1DraftedSet.has(name)) return pass1Round;
                        if (pass2DraftedSet.has(name)) return pass2Round;
                        if (othersTookSet.has(name)) return pass2Round;
                        return pass1Round; // passed cards
                    };

                    // Build all cards for each column, sorted by rank
                    const byRank = (a, b) => (cardMap[a]?.rank || 999) - (cardMap[b]?.rank || 999);

                    const allOccs = [...new Set([
                        ...(hasPass1 && pass1OccPick ? [pass1OccPick] : []),
                        ...pass1Hand.filter(n => cardMap[n]?.type === 'Occupation' && !allDraftedNames.has(n)),
                        ...othersTookCards.filter(n => cardMap[n]?.type === 'Occupation'),
                        ...(hasPass2 && pass2OccPick ? [pass2OccPick] : []),
                    ])].sort(byRank);

                    const allMins = [...new Set([
                        ...(hasPass1 && pass1MinPick ? [pass1MinPick] : []),
                        ...pass1Hand.filter(n => cardMap[n]?.type === 'Minor Improvement' && !allDraftedNames.has(n)),
                        ...othersTookCards.filter(n => cardMap[n]?.type === 'Minor Improvement'),
                        ...(hasPass2 && pass2MinPick ? [pass2MinPick] : []),
                    ])].sort(byRank);

                    return (
                        <div key={handNum} className="prior-hand-card">
                            <div className="prior-hand-header">Hand {handNum}</div>
                            <div style={{ display: 'flex', gap: '12px' }}>
                                <div style={{ flex: 1 }}>
                                    <div style={{ fontSize: '0.75em', fontWeight: 600, color: '#888', marginBottom: '4px' }}>Occ</div>
                                    {allOccs.map(name => renderMiniCard(name, getRoundForCard(name)))}
                                </div>
                                <div style={{ flex: 1 }}>
                                    <div style={{ fontSize: '0.75em', fontWeight: 600, color: '#888', marginBottom: '4px' }}>Minor</div>
                                    {allMins.map(name => renderMiniCard(name, getRoundForCard(name)))}
                                </div>
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
}

// ─── YourHand Component ─────────────────────────────────────────────
function YourHand({ draftedCards, cardMap, onCardClick }) {
    const allDrafted = [];
    Object.entries(draftedCards).forEach(([round, picks]) => {
        const passNum = getPassNumber(round);
        const handNum = getHandNumber(round);
        if (picks.occupation && cardMap[picks.occupation]) {
            allDrafted.push({ ...cardMap[picks.occupation], _round: parseInt(round), _passNum: passNum, _handNum: handNum });
        }
        if (picks.minor && cardMap[picks.minor]) {
            allDrafted.push({ ...cardMap[picks.minor], _round: parseInt(round), _passNum: passNum, _handNum: handNum });
        }
    });

    if (allDrafted.length === 0) return null;

    const draftedOccs = allDrafted.filter(c => c.type === 'Occupation').sort((a, b) => a.rank - b.rank);
    const draftedMins = allDrafted.filter(c => c.type === 'Minor Improvement').sort((a, b) => a.rank - b.rank);

    const renderDraftedCard = (card) => (
        <div key={card.name} className="card-row clickable" onClick={(e) => onCardClick && onCardClick(card.name, e)}>
            <span className="card-name">{card.name}</span>
            <div className="card-stat"><div className="card-stat-label">Rank</div><div>#{card.rank}</div></div>
            <div className="card-stat"><div className="card-stat-label">ADP</div><div>{card.adp}</div></div>
            <div className="card-stat"><div className="card-stat-label">Elo/Play</div><div>{card.elo_per_play || '—'}</div></div>
            <div className="card-stat"><div className="card-stat-label">H{card._handNum}</div><div style={{ color: '#8B6914' }}><span className="pick-badge">{card._passNum}</span></div></div>
        </div>
    );

    return (
        <div className="your-hand-section">
            <div className="your-hand-title">Your Drafted Cards ({draftedOccs.length} occ, {draftedMins.length} minor)</div>
            <div className="hand-columns">
                <div className="hand-column">
                    <div className="column-header"><span>Occupations</span></div>
                    <div className="card-list">{draftedOccs.map(renderDraftedCard)}</div>
                </div>
                <div className="hand-column">
                    <div className="column-header"><span>Minor Improvements</span></div>
                    <div className="card-list">{draftedMins.map(renderDraftedCard)}</div>
                </div>
            </div>
        </div>
    );
}

// ─── CardDetailPopover Component ─────────────────────────────────────
function CardDetailPopover({ card, anchorRect, onClose }) {
    const popoverRef = useRef(null);
    const [position, setPosition] = useState({ top: 0, left: 0 });

    useEffect(() => {
        if (!anchorRect || !popoverRef.current) return;
        const popover = popoverRef.current;
        const rect = popover.getBoundingClientRect();
        const viewportW = window.innerWidth;
        const viewportH = window.innerHeight;

        let top = anchorRect.top;
        let left = anchorRect.right + 8;

        if (left + rect.width > viewportW - 16) {
            left = anchorRect.left - rect.width - 8;
        }
        if (left < 16) {
            left = Math.max(16, (viewportW - rect.width) / 2);
        }
        if (top + rect.height > viewportH - 16) {
            top = viewportH - rect.height - 16;
        }
        if (top < 16) top = 16;

        setPosition({ top, left });
    }, [anchorRect]);

    useEffect(() => {
        const handleMouseDown = (e) => {
            if (popoverRef.current && !popoverRef.current.contains(e.target)) {
                onClose();
            }
        };
        const handleKeyDown = (e) => {
            if (e.key === 'Escape') onClose();
        };
        document.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('keydown', handleKeyDown);
        return () => {
            document.removeEventListener('mousedown', handleMouseDown);
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, [onClose]);

    const imagePath = getCardImagePath(card.name);

    return (
        <div
            ref={popoverRef}
            className="card-detail-popover"
            style={{ top: position.top, left: position.left }}
        >
            <button className="popover-close" onClick={onClose}>&times;</button>
            <div className="popover-header">
                <span className="popover-name">{card.name}</span>
                <span className="popover-rank">#{card.rank}</span>
            </div>
            <div className="popover-meta">
                {card.type && <span className="popover-tag">{card.type}</span>}
                {card.card_id && <span className="popover-tag">{card.card_id}</span>}
                {card.cost && <span className="popover-tag">Cost: {card.cost}</span>}
                {card.vps && <span className="popover-tag">VPs: {card.vps}</span>}
            </div>
            {imagePath && (
                <div className="popover-image">
                    <img src={imagePath} alt={card.name} />
                </div>
            )}
            {card.prerequisites && (
                <div className="popover-prereqs">
                    <strong>Prerequisites:</strong> {card.prerequisites}
                </div>
            )}
            <div className="popover-description">
                {card.description || 'No description available'}
            </div>
            <div className="popover-stats">
                <div><span className="popover-stat-label">PWR</span> {card.pwr}</div>
                <div><span className="popover-stat-label">ADP</span> {card.adp}</div>
                <div><span className="popover-stat-label">Play Rate</span> {card.play_rate}</div>
                <div><span className="popover-stat-label">Elo/Play</span> {card.elo_per_play || '—'}</div>
                <div><span className="popover-stat-label">Value</span> {card.value ? parseFloat(card.value).toFixed(1) : '—'}</div>
                <div><span className="popover-stat-label">VWP</span> {card.value_when_played ? parseFloat(card.value_when_played).toFixed(1) : '—'}</div>
            </div>
        </div>
    );
}

// ─── SummaryView Component ──────────────────────────────────────────
function SummaryView({ draftedCards, cardMap, onNewDraft, hands, othersDrafted, onCardClick }) {
    const [showAllDrafted, setShowAllDrafted] = useState(false);

    const allDrafted = [];
    Object.entries(draftedCards).forEach(([round, picks]) => {
        const passNum = getPassNumber(round);
        const handNum = getHandNumber(round);
        if (picks.occupation && cardMap[picks.occupation]) {
            allDrafted.push({ ...cardMap[picks.occupation], _round: parseInt(round), _passNum: passNum, _handNum: handNum });
        }
        if (picks.minor && cardMap[picks.minor]) {
            allDrafted.push({ ...cardMap[picks.minor], _round: parseInt(round), _passNum: passNum, _handNum: handNum });
        }
    });

    const occs = allDrafted.filter(c => c.type === 'Occupation').sort((a, b) => a.rank - b.rank);
    const mins = allDrafted.filter(c => c.type === 'Minor Improvement').sort((a, b) => a.rank - b.rank);

    // Build all known drafted cards (user + others)
    const allKnownDrafted = useMemo(() => {
        const result = [];

        // User's drafted cards
        Object.entries(draftedCards).forEach(([round, picks]) => {
            const passNum = getPassNumber(round);
            const handNum = getHandNumber(round);
            if (picks.occupation && cardMap[picks.occupation]) {
                result.push({ ...cardMap[picks.occupation], _round: parseInt(round), _passNum: passNum, _handNum: handNum, _drafter: 'you' });
            }
            if (picks.minor && cardMap[picks.minor]) {
                result.push({ ...cardMap[picks.minor], _round: parseInt(round), _passNum: passNum, _handNum: handNum, _drafter: 'you' });
            }
        });

        // Others' drafted cards — find which hand they appeared in
        const othersDraftedSet = new Set(othersDrafted || []);
        if (othersDraftedSet.size > 0) {
            const seen = new Set();
            Object.entries(hands || {}).forEach(([round, handNames]) => {
                const roundNum = parseInt(round);
                const handNum = getHandNumber(roundNum);
                handNames.forEach(name => {
                    if (othersDraftedSet.has(name) && cardMap[name] && !seen.has(name)) {
                        seen.add(name);
                        result.push({
                            ...cardMap[name],
                            _round: roundNum,
                            _handNum: handNum,
                            _drafter: 'other',
                        });
                    }
                });
            });
        }

        result.sort((a, b) => a.rank - b.rank);
        return result;
    }, [draftedCards, cardMap, hands, othersDrafted]);

    const renderSummaryCard = (card) => (
        <div key={card.name} className="summary-card clickable" onClick={(e) => onCardClick && onCardClick(card.name, e)}>
            <div className="card-name">{card.name}</div>
            <div className="card-stats">
                <span>Rank #{card.rank}</span>
                <span>ADP {card.adp}</span>
                <span>Elo/Play {card.elo_per_play || '—'}</span>
                <span>Value {card.value ? parseFloat(card.value).toFixed(1) : '—'}</span>
                <span>Play Rate {card.play_rate}</span>
            </div>
        </div>
    );

    const renderAllDraftedCard = (card) => (
        <div key={`${card.name}-${card._drafter}`} className={`summary-card clickable${card._drafter === 'other' ? ' others-pick' : ''}`} onClick={(e) => onCardClick && onCardClick(card.name, e)}>
            <div className="card-name">
                {card._drafter === 'other' && <span className="other-badge">Other</span>}
                {card.name}
            </div>
            <div className="card-stats">
                <span>Rank #{card.rank}</span>
                <span>ADP {card.adp}</span>
                <span>H{card._handNum}</span>
                {card._drafter === 'you' && <span>Pass {card._passNum}</span>}
            </div>
        </div>
    );

    const allKnownOccs = allKnownDrafted.filter(c => c.type === 'Occupation');
    const allKnownMins = allKnownDrafted.filter(c => c.type === 'Minor Improvement');

    return (
        <div className="summary-section">
            <div className="summary-title">
                {showAllDrafted ? 'All Known Drafted Cards' : 'Draft Complete — Your Final Hand'}
            </div>
            <div className="summary-toggle">
                <button
                    className={`toggle-btn${!showAllDrafted ? ' active' : ''}`}
                    onClick={() => setShowAllDrafted(false)}
                >
                    Your Hand
                </button>
                <button
                    className={`toggle-btn${showAllDrafted ? ' active' : ''}`}
                    onClick={() => setShowAllDrafted(true)}
                >
                    All Drafted ({allKnownDrafted.length})
                </button>
            </div>

            {!showAllDrafted ? (
                <div className="summary-columns">
                    <div>
                        <div className="summary-column-title">Occupations ({occs.length}/7)</div>
                        {occs.map(renderSummaryCard)}
                    </div>
                    <div>
                        <div className="summary-column-title">Minor Improvements ({mins.length}/7)</div>
                        {mins.map(renderSummaryCard)}
                    </div>
                </div>
            ) : (
                <div className="summary-columns">
                    <div>
                        <div className="summary-column-title">Occupations ({allKnownOccs.length})</div>
                        {allKnownOccs.map(renderAllDraftedCard)}
                    </div>
                    <div>
                        <div className="summary-column-title">Minor Improvements ({allKnownMins.length})</div>
                        {allKnownMins.map(renderAllDraftedCard)}
                    </div>
                </div>
            )}

            <div style={{ textAlign: 'center', marginTop: '24px' }}>
                <button className="btn btn-primary" onClick={onNewDraft} style={{ background: 'rgba(255,255,255,0.2)', fontSize: '1.1em' }}>
                    Start New Draft
                </button>
            </div>
        </div>
    );
}

// ─── DraftApp Component ─────────────────────────────────────────────
function DraftApp() {
    const [cards, setCards] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    // Draft state — all of these get persisted to localStorage
    const [currentRound, setCurrentRound] = useState(1);
    const [draftStarted, setDraftStarted] = useState(false);
    const [currentHandNames, setCurrentHandNames] = useState([]);
    const [hands, setHands] = useState({});
    const [draftedCards, setDraftedCards] = useState({});
    const [selectedOccupation, setSelectedOccupation] = useState(null);
    const [selectedMinor, setSelectedMinor] = useState(null);
    const [sortKey, setSortKey] = useState('rank');

    // Rounds 5-7: marking phase + others' drafted cards
    const [markingPhase, setMarkingPhase] = useState(false);
    const [othersDrafted, setOthersDrafted] = useState([]);

    // Popover state for card detail
    const [popoverCard, setPopoverCard] = useState(null);
    const [popoverAnchor, setPopoverAnchor] = useState(null);

    // Track whether initial load from localStorage is done
    const [restoredFromStorage, setRestoredFromStorage] = useState(false);

    // Load card data
    useEffect(() => {
        fetch('agricola-cards.json')
            .then(res => {
                if (!res.ok) throw new Error('Failed to load card data');
                return res.json();
            })
            .then(data => {
                setCards(data);

                // Restore saved state after cards are loaded
                const saved = loadSavedState();
                if (saved && saved.draftStarted) {
                    // Validate card names still exist in the database
                    const validNames = new Set(data.map(c => c.name));
                    const filterNames = (names) => (names || []).filter(n => validNames.has(n));

                    setCurrentRound(saved.currentRound || 1);
                    setDraftStarted(true);
                    setCurrentHandNames(filterNames(saved.currentHandNames));
                    setSortKey(saved.sortKey || 'rank');
                    setMarkingPhase(saved.markingPhase || false);
                    setOthersDrafted(filterNames(saved.othersDrafted));
                    setSelectedOccupation(null);
                    setSelectedMinor(null);

                    // Restore hands object (filter each hand's card names)
                    const restoredHands = {};
                    if (saved.hands) {
                        Object.entries(saved.hands).forEach(([round, handNames]) => {
                            restoredHands[round] = filterNames(handNames);
                        });
                    }
                    setHands(restoredHands);

                    // Restore draftedCards (validate names)
                    const restoredDrafted = {};
                    if (saved.draftedCards) {
                        Object.entries(saved.draftedCards).forEach(([round, picks]) => {
                            restoredDrafted[round] = {
                                occupation: picks.occupation && validNames.has(picks.occupation) ? picks.occupation : null,
                                minor: picks.minor && validNames.has(picks.minor) ? picks.minor : null,
                            };
                        });
                    }
                    setDraftedCards(restoredDrafted);
                }
                setRestoredFromStorage(true);
                setLoading(false);
            })
            .catch(err => {
                setError(err.message);
                setLoading(false);
            });
    }, []);

    // Save state to localStorage on changes (after initial restore)
    useEffect(() => {
        if (!restoredFromStorage) return;
        if (!draftStarted) {
            clearSavedState();
            return;
        }
        saveState({
            currentRound,
            draftStarted,
            currentHandNames,
            hands,
            draftedCards,
            sortKey,
            markingPhase,
            othersDrafted,
        });
    }, [restoredFromStorage, currentRound, draftStarted, currentHandNames, hands, draftedCards, sortKey, markingPhase, othersDrafted]);

    // Random icon for title
    const [titleIcon] = useState(() => {
        const icons = [
            'Icons/Grain.webp', 'Icons/Wood.png', 'Icons/Clay.png',
            'Icons/Reed.webp', 'Icons/Stone.png', 'Icons/Sheep.webp',
            'Icons/Cow.webp', 'Icons/Pig.webp', 'Icons/Veg.webp',
            'Icons/Cornucopia.webp'
        ];
        return icons[Math.floor(Math.random() * icons.length)];
    });

    // Card lookup map
    const cardMap = useMemo(() => {
        const map = {};
        cards.forEach(c => { map[c.name] = c; });
        return map;
    }, [cards]);

    // Is this a returning-hand round?
    const isReturningRound = currentRound >= 5 && currentRound <= 7;

    // Current hand card objects split by type
    const currentHandCards = useMemo(() => {
        return currentHandNames.map(name => cardMap[name]).filter(Boolean);
    }, [currentHandNames, cardMap]);

    const occupations = useMemo(() =>
        currentHandCards.filter(c => c.type === 'Occupation'), [currentHandCards]);
    const minors = useMemo(() =>
        currentHandCards.filter(c => c.type === 'Minor Improvement'), [currentHandCards]);

    // Set of all card names used across all rounds (to prevent duplicates in search)
    const allUsedCardNames = useMemo(() => {
        const names = new Set(currentHandNames);
        Object.values(hands).forEach(handNames => {
            handNames.forEach(n => names.add(n));
        });
        return names;
    }, [currentHandNames, hands]);

    const expectedHandSize = HAND_SIZE_BY_ROUND[currentRound] || 10;

    // For returning rounds, hand is "full" once auto-populated (no manual entry needed)
    const handIsFull = isReturningRound
        ? currentHandNames.length > 0  // returning hands are pre-populated
        : (occupations.length === expectedHandSize && minors.length === expectedHandSize);

    // For draft selection: filter out faded cards
    const othersDraftedSet = useMemo(() => new Set(othersDrafted), [othersDrafted]);
    const availableOccs = useMemo(() => occupations.filter(c => !othersDraftedSet.has(c.name)), [occupations, othersDraftedSet]);
    const availableMins = useMemo(() => minors.filter(c => !othersDraftedSet.has(c.name)), [minors, othersDraftedSet]);

    const canConfirm = !markingPhase && selectedOccupation && selectedMinor;

    // ─── Auto-populate returning hands ─────────────────────────────
    useEffect(() => {
        if (!draftStarted || !isReturningRound || currentHandNames.length > 0) return;
        const sourceRound = RETURNING_HAND_SOURCE[currentRound];
        if (!sourceRound || !hands[sourceRound]) return;

        const sourceHand = hands[sourceRound];
        const sourceDrafted = draftedCards[sourceRound] || {};
        const userDraftedFromSource = new Set([sourceDrafted.occupation, sourceDrafted.minor].filter(Boolean));

        // Return all cards from the source hand except what the user drafted in that round
        const returningCards = sourceHand.filter(name => !userDraftedFromSource.has(name));
        setCurrentHandNames(returningCards);
        setMarkingPhase(true);
    }, [currentRound, draftStarted, isReturningRound, currentHandNames.length, hands, draftedCards]);

    // ─── Handlers ──────────────────────────────────────────────────
    const handleNewDraft = () => {
        setCurrentRound(1);
        setCurrentHandNames([]);
        setHands({});
        setDraftedCards({});
        setSelectedOccupation(null);
        setSelectedMinor(null);
        setSortKey('rank');
        setMarkingPhase(false);
        setOthersDrafted([]);
        setDraftStarted(true);
    };

    const handleResetDraft = () => {
        if (draftStarted && !window.confirm('Reset the current draft? All progress will be lost.')) return;
        setCurrentRound(1);
        setCurrentHandNames([]);
        setHands({});
        setDraftedCards({});
        setSelectedOccupation(null);
        setSelectedMinor(null);
        setSortKey('rank');
        setMarkingPhase(false);
        setOthersDrafted([]);
        setDraftStarted(false);
        clearSavedState();
    };

    const handleAddCard = useCallback((card) => {
        setCurrentHandNames(prev => {
            if (prev.includes(card.name)) return prev;
            const currentCards = prev.map(n => cardMap[n]).filter(Boolean);
            const typeCount = currentCards.filter(c => c.type === card.type).length;
            if (typeCount >= (HAND_SIZE_BY_ROUND[currentRound] || 10)) return prev;
            return [...prev, card.name];
        });
    }, [cardMap, currentRound]);

    const handleRemoveCard = useCallback((cardName) => {
        setCurrentHandNames(prev => prev.filter(n => n !== cardName));
        if (cardName === selectedOccupation) setSelectedOccupation(null);
        if (cardName === selectedMinor) setSelectedMinor(null);
    }, [selectedOccupation, selectedMinor]);

    const handleSelectOccupation = useCallback((cardName) => {
        if (othersDraftedSet.has(cardName)) return;
        setSelectedOccupation(prev => prev === cardName ? null : cardName);
    }, [othersDraftedSet]);

    const handleSelectMinor = useCallback((cardName) => {
        if (othersDraftedSet.has(cardName)) return;
        setSelectedMinor(prev => prev === cardName ? null : cardName);
    }, [othersDraftedSet]);

    const handleToggleFaded = useCallback((cardName) => {
        setOthersDrafted(prev =>
            prev.includes(cardName)
                ? prev.filter(n => n !== cardName)
                : [...prev, cardName]
        );
    }, []);

    const handleMiniCardClick = useCallback((cardName, event) => {
        const card = cardMap[cardName];
        if (!card) return;
        const rect = event.currentTarget.getBoundingClientRect();
        setPopoverCard(card);
        setPopoverAnchor(rect);
    }, [cardMap]);

    const handlePopoverClose = useCallback(() => {
        setPopoverCard(null);
        setPopoverAnchor(null);
    }, []);

    const handleDoneMarking = useCallback(() => {
        setMarkingPhase(false);
        setSelectedOccupation(null);
        setSelectedMinor(null);
    }, []);

    const handleBackToMarking = useCallback(() => {
        setMarkingPhase(true);
        setSelectedOccupation(null);
        setSelectedMinor(null);
    }, []);

    const handleConfirmDraft = useCallback(() => {
        if (!selectedOccupation || !selectedMinor) return;
        setHands(prev => ({ ...prev, [currentRound]: [...currentHandNames] }));
        setDraftedCards(prev => ({
            ...prev,
            [currentRound]: { occupation: selectedOccupation, minor: selectedMinor }
        }));
        setCurrentHandNames([]);
        setSelectedOccupation(null);
        setSelectedMinor(null);
        setMarkingPhase(false);
        setCurrentRound(prev => prev + 1);
    }, [selectedOccupation, selectedMinor, currentHandNames, currentRound]);

    const handleUndo = useCallback(() => {
        if (currentRound <= 1) return;
        const prevRound = currentRound - 1;
        setCurrentHandNames(hands[prevRound] || []);
        setHands(prev => { const next = { ...prev }; delete next[prevRound]; return next; });
        setDraftedCards(prev => { const next = { ...prev }; delete next[prevRound]; return next; });
        setSelectedOccupation(null);
        setSelectedMinor(null);
        // If undoing into a returning round, restore marking phase
        if (prevRound >= 5) {
            setMarkingPhase(false); // drop into draft mode since hand was already marked
        } else {
            setMarkingPhase(false);
        }
        setCurrentRound(prevRound);
    }, [currentRound, hands]);

    // ─── Render ────────────────────────────────────────────────────
    if (loading) return <div className="loading">Loading card data...</div>;
    if (error) return <div className="loading">Error: {error}</div>;

    const draftComplete = draftStarted && currentRound > 7;

    return (
        <div>
            <nav className="nav-bar">
                <a href="index.html" className="nav-link">Card Lookup</a>
                <a href="draft.html" className="nav-link active">Draft Tool</a>
            </nav>

            <div className="draft-container">
                {/* Header */}
                <div className="draft-header">
                    <h1 className="draft-title">
                        <img src={titleIcon} alt="" className="title-icon" />
                        Agricola Draft Tool
                    </h1>
                    <div className="draft-header-right">
                        {draftStarted && !draftComplete && (
                            <div className="round-indicator">
                                Round <span className="round-num">{currentRound}</span> of 7
                                {isReturningRound && <span style={{ fontSize: '0.75em', marginLeft: '6px', color: '#888' }}>(returning)</span>}
                            </div>
                        )}
                        {draftComplete && (
                            <div className="round-indicator" style={{ background: '#d4edda', color: '#155724' }}>
                                Draft Complete
                            </div>
                        )}
                        {!draftStarted ? (
                            <button className="btn btn-primary" onClick={handleNewDraft}>New Draft</button>
                        ) : (
                            <button className="btn btn-danger" onClick={handleResetDraft}>Reset Draft</button>
                        )}
                    </div>
                </div>

                {/* Welcome state */}
                {!draftStarted && (
                    <div className="hand-section">
                        <div className="empty-hand">
                            Click "New Draft" to begin. You'll enter your starting hand of 10 occupations and 10 minor improvements, then draft 7 of each across 7 rounds.
                        </div>
                    </div>
                )}

                {/* Draft complete — Summary view */}
                {draftComplete && (
                    <>
                        <PriorHands hands={hands} draftedCards={draftedCards} cardMap={cardMap} currentRound={currentRound} othersDrafted={othersDrafted} onCardClick={handleMiniCardClick} />
                        <SummaryView draftedCards={draftedCards} cardMap={cardMap} onNewDraft={handleNewDraft} hands={hands} othersDrafted={othersDrafted} onCardClick={handleMiniCardClick} />
                    </>
                )}

                {/* Active draft — rounds 1-7 */}
                {draftStarted && !draftComplete && (
                    <>
                        {/* Prior Hands */}
                        <PriorHands hands={hands} draftedCards={draftedCards} cardMap={cardMap} currentRound={currentRound} othersDrafted={othersDrafted} onCardClick={handleMiniCardClick} />

                        {/* Search (only for rounds 1-4 manual entry) */}
                        {!isReturningRound && (
                            <CardSearch
                                cards={cards}
                                onAddCard={handleAddCard}
                                allUsedCardNames={allUsedCardNames}
                            />
                        )}

                        {/* Marking phase banner (rounds 5-7) */}
                        {isReturningRound && markingPhase && (
                            <div className="marking-banner">
                                <div className="marking-banner-text">
                                    <strong>Marking Phase:</strong> Click cards that other players have drafted from this returning hand. Click "Done Marking" when ready to make your pick.
                                </div>
                                <button className="btn btn-primary" onClick={handleDoneMarking}>
                                    Done Marking
                                </button>
                            </div>
                        )}

                        {/* Back to marking button */}
                        {isReturningRound && !markingPhase && (
                            <div className="marking-banner" style={{ background: '#d1ecf1', borderColor: '#bee5eb' }}>
                                <div className="marking-banner-text" style={{ color: '#0c5460' }}>
                                    <strong>Draft Phase:</strong> Select 1 occupation and 1 minor improvement to draft.
                                </div>
                                <button className="btn btn-secondary" onClick={handleBackToMarking}>
                                    ← Back to Marking
                                </button>
                            </div>
                        )}

                        {/* Current Hand */}
                        <div className="hand-section">
                            <div className="sort-controls">
                                <span style={{ fontSize: '0.85em', color: '#888', marginRight: '4px' }}>Sort by:</span>
                                {SORT_OPTIONS.map(opt => (
                                    <button
                                        key={opt.key}
                                        className={`sort-btn${sortKey === opt.key ? ' active' : ''}`}
                                        onClick={() => setSortKey(opt.key)}
                                    >
                                        {opt.label}
                                    </button>
                                ))}
                            </div>

                            <div className="hand-columns">
                                <HandColumn
                                    title="Occupations"
                                    cards={occupations}
                                    expectedCount={expectedHandSize}
                                    sortKey={sortKey}
                                    onRemoveCard={handleRemoveCard}
                                    onSelectCard={(!markingPhase && handIsFull) ? handleSelectOccupation : null}
                                    selectedCardName={!markingPhase ? selectedOccupation : null}
                                    showRemove={!isReturningRound && !handIsFull}
                                    fadedCardNames={isReturningRound ? othersDrafted : null}
                                    onToggleFaded={markingPhase ? handleToggleFaded : null}
                                />
                                <HandColumn
                                    title="Minor Improvements"
                                    cards={minors}
                                    expectedCount={expectedHandSize}
                                    sortKey={sortKey}
                                    onRemoveCard={handleRemoveCard}
                                    onSelectCard={(!markingPhase && handIsFull) ? handleSelectMinor : null}
                                    selectedCardName={!markingPhase ? selectedMinor : null}
                                    showRemove={!isReturningRound && !handIsFull}
                                    fadedCardNames={isReturningRound ? othersDrafted : null}
                                    onToggleFaded={markingPhase ? handleToggleFaded : null}
                                />
                            </div>

                            {/* Draft action buttons */}
                            {!markingPhase && handIsFull && (
                                <div className="draft-actions">
                                    {currentRound > 1 && (
                                        <button className="btn btn-secondary" onClick={handleUndo}>
                                            ← Undo Round {currentRound - 1}
                                        </button>
                                    )}
                                    <button
                                        className="btn btn-primary"
                                        disabled={!canConfirm}
                                        onClick={handleConfirmDraft}
                                    >
                                        {canConfirm
                                            ? `Confirm Draft — ${cardMap[selectedOccupation]?.name} + ${cardMap[selectedMinor]?.name}`
                                            : 'Select 1 Occupation + 1 Minor Improvement'}
                                    </button>
                                </div>
                            )}

                            {!isReturningRound && !handIsFull && (
                                <div className="draft-actions">
                                    {currentRound > 1 && (
                                        <button className="btn btn-secondary" onClick={handleUndo}>
                                            ← Undo Round {currentRound - 1}
                                        </button>
                                    )}
                                    <div style={{ fontSize: '0.9em', color: '#888', padding: '10px' }}>
                                        Add {expectedHandSize - occupations.length} more occupation{expectedHandSize - occupations.length !== 1 ? 's' : ''} and {expectedHandSize - minors.length} more minor improvement{expectedHandSize - minors.length !== 1 ? 's' : ''} to this hand
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Your Hand (drafted so far) */}
                        <YourHand draftedCards={draftedCards} cardMap={cardMap} onCardClick={handleMiniCardClick} />
                    </>
                )}
            </div>

            {/* Card Detail Popover */}
            {popoverCard && popoverAnchor && (
                <CardDetailPopover
                    card={popoverCard}
                    anchorRect={popoverAnchor}
                    onClose={handlePopoverClose}
                />
            )}
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<DraftApp />);

// Set random favicon
const RESOURCE_ICONS = [
    'Icons/Grain.webp', 'Icons/Wood.png', 'Icons/Clay.png',
    'Icons/Reed.webp', 'Icons/Stone.png', 'Icons/Sheep.webp',
    'Icons/Cow.webp', 'Icons/Pig.webp', 'Icons/Veg.webp',
    'Icons/Cornucopia.webp'
];
const randomIcon = RESOURCE_ICONS[Math.floor(Math.random() * RESOURCE_ICONS.length)];
const favicon = document.querySelector('link[rel="icon"]');
favicon.href = randomIcon;
    </script>
</body>
</html>
