<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="Icons/Grain.webp">
    <title>Agricola Draft Tool</title>
    <link rel="stylesheet" href="css/draft.css?v=4">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="js/card-image-list.js"></script>
    <script src="js/tag-definitions.js"></script>
    <script src="js/screenshot-ocr.js"></script>
    <script src="js/strategy-advisor.js"></script>
</head>
<body>
    <div id="root">
        <div class="loading">Loading draft tool...</div>
    </div>

    <script type="text/babel">
const { useState, useEffect, useRef, useCallback, useMemo } = React;

// ─── Constants ──────────────────────────────────────────────────────
const HAND_SIZE_BY_ROUND = { 1: 10, 2: 9, 3: 8, 4: 7, 5: 6, 6: 5, 7: 4 };

// Rounds 5-7 get back hands from rounds 1-3 (4-player rotation)
const RETURNING_HAND_SOURCE = { 5: 1, 6: 2, 7: 3 };

const SORT_OPTIONS = [
    { key: 'rank', label: 'Rank', getValue: c => c.rank, ascending: true },
    { key: 'adp', label: 'ADP', getValue: c => parseFloat(c.adp) || 999, ascending: true },
    { key: 'elo_per_play', label: 'Elo/Play', getValue: c => parseFloat(c.elo_per_play) || 0, ascending: false },
    { key: 'value', label: 'Draft Value', getValue: c => parseFloat(c.value) || 0, ascending: false },
];

const STORAGE_KEY = 'agricola-draft-state';

// ─── Image resolution (shared with index.html) ─────────────────────
const cardImageMap = {};

function normalizeForMatch(str) {
    return str.toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/[\s\-'\.]/g, '');
}

CARD_IMAGE_LIST.forEach(filename => {
    const nameWithoutExt = filename.replace(/\.png$/, '');
    const normalized = normalizeForMatch(nameWithoutExt);
    cardImageMap[normalized] = filename;
});

function getCardImagePath(cardName) {
    const normalized = normalizeForMatch(cardName);
    const filename = cardImageMap[normalized];
    return filename ? `card-images/${filename}` : null;
}

// ─── Pass number helper ─────────────────────────────────────────────
function getPassNumber(round) {
    return parseInt(round) <= 4 ? 1 : 2;
}

// ─── Hand number helper (rounds 5-7 map back to hands 1-3) ─────────
function getHandNumber(round) {
    const r = parseInt(round);
    return RETURNING_HAND_SOURCE[r] || r;
}

// Hand grouping: which rounds belong to each hand
const HAND_GROUPS = [
    { handNum: 1, pass1Round: 1, pass2Round: 5 },
    { handNum: 2, pass1Round: 2, pass2Round: 6 },
    { handNum: 3, pass1Round: 3, pass2Round: 7 },
    { handNum: 4, pass1Round: 4, pass2Round: null },
];

// ─── localStorage helpers ───────────────────────────────────────────
function loadSavedState() {
    try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
    } catch { return null; }
}

function saveState(state) {
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch { /* ignore quota errors */ }
}

function clearSavedState() {
    localStorage.removeItem(STORAGE_KEY);
}

// ─── CardSearch Component ───────────────────────────────────────────
function CardSearch({ cards, onAddCard, onAddTempCard, allUsedCardNames, children }) {
    const [query, setQuery] = useState('');
    const [highlightIndex, setHighlightIndex] = useState(-1);
    const [showTempForm, setShowTempForm] = useState(false);
    const [tempName, setTempName] = useState('');
    const [tempType, setTempType] = useState('Occupation');
    const [tempDesc, setTempDesc] = useState('');
    const [showDesc, setShowDesc] = useState(false);
    const inputRef = useRef(null);
    const suggestionsRef = useRef(null);

    const matches = useMemo(() => {
        if (query.length === 0) return [];
        const q = query.toLowerCase();
        return cards
            .filter(card =>
                card.name.toLowerCase().includes(q) &&
                !allUsedCardNames.has(card.name)
            )
            .slice(0, 10);
    }, [query, cards, allUsedCardNames]);

    const selectCard = useCallback((card) => {
        onAddCard(card);
        setQuery('');
        setHighlightIndex(-1);
        setShowTempForm(false);
        setTimeout(() => inputRef.current?.focus(), 0);
    }, [onAddCard]);

    const handleKeyDown = useCallback((e) => {
        if (showTempForm) return;
        if (matches.length === 0) return;
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            setHighlightIndex(prev => Math.min(prev + 1, matches.length - 1));
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            setHighlightIndex(prev => Math.max(prev - 1, 0));
        } else if (e.key === 'Enter') {
            e.preventDefault();
            if (highlightIndex >= 0 && highlightIndex < matches.length) {
                selectCard(matches[highlightIndex]);
            } else if (matches.length > 0) {
                selectCard(matches[0]);
            }
        } else if (e.key === 'Escape') {
            setQuery('');
            setHighlightIndex(-1);
        }
    }, [matches, highlightIndex, selectCard, showTempForm]);

    const openTempForm = useCallback(() => {
        setTempName(query);
        setTempType('Occupation');
        setTempDesc('');
        setShowDesc(false);
        setShowTempForm(true);
    }, [query]);

    const handleTempSubmit = useCallback(() => {
        if (!tempName.trim()) return;
        onAddTempCard(tempName.trim(), tempType, tempDesc.trim());
        setQuery('');
        setShowTempForm(false);
        setTempName('');
        setTempDesc('');
        setShowDesc(false);
        setTimeout(() => inputRef.current?.focus(), 0);
    }, [tempName, tempType, tempDesc, onAddTempCard]);

    const cancelTempForm = useCallback(() => {
        setShowTempForm(false);
        setTimeout(() => inputRef.current?.focus(), 0);
    }, []);

    useEffect(() => {
        if (highlightIndex >= 0 && suggestionsRef.current) {
            const items = suggestionsRef.current.querySelectorAll('.suggestion-item');
            if (items[highlightIndex]) {
                items[highlightIndex].scrollIntoView({ block: 'nearest' });
            }
        }
    }, [highlightIndex]);

    const showNoMatchPrompt = query.length > 1 && matches.length === 0 && !showTempForm;

    return (
        <div className="search-section">
            <div className="search-label">Search for a card to add to this hand</div>
            <input
                ref={inputRef}
                type="text"
                className="search-input"
                placeholder="Type card name..."
                value={query}
                onChange={e => { setQuery(e.target.value); setHighlightIndex(0); setShowTempForm(false); }}
                onKeyDown={handleKeyDown}
                autoComplete="off"
                autoFocus
            />
            {matches.length > 0 && (
                <div className="suggestions active" ref={suggestionsRef}>
                    {matches.map((card, i) => (
                        <div
                            key={card.name}
                            className={`suggestion-item${i === highlightIndex ? ' highlighted' : ''}`}
                            onClick={() => selectCard(card)}
                            onMouseEnter={() => setHighlightIndex(i)}
                        >
                            <span className="suggestion-rank">#{card.rank}</span>
                            <span className="suggestion-name">{card.name}</span>
                            <span className="suggestion-type">{card.type === 'Occupation' ? 'Occ' : 'Minor'}</span>
                        </div>
                    ))}
                </div>
            )}
            {showNoMatchPrompt && (
                <div className="temp-card-prompt">
                    <span className="temp-card-prompt-text">No matching cards found.</span>
                    <button className="temp-card-prompt-btn" onClick={openTempForm}>
                        + Add "{query}" as temporary card
                    </button>
                </div>
            )}
            {showTempForm && (
                <div className="temp-card-form">
                    <div className="temp-card-form-row">
                        <label>Name</label>
                        <input
                            type="text"
                            value={tempName}
                            onChange={e => setTempName(e.target.value)}
                            className="temp-card-input"
                            autoFocus
                        />
                    </div>
                    <div className="temp-card-form-row">
                        <label>Type</label>
                        <div className="temp-card-type-toggle">
                            <button
                                className={`type-btn${tempType === 'Occupation' ? ' active' : ''}`}
                                onClick={() => setTempType('Occupation')}
                            >Occupation</button>
                            <button
                                className={`type-btn${tempType === 'Minor Improvement' ? ' active' : ''}`}
                                onClick={() => setTempType('Minor Improvement')}
                            >Minor Improvement</button>
                        </div>
                    </div>
                    {!showDesc && (
                        <button className="temp-card-add-desc" onClick={() => setShowDesc(true)}>
                            + Add description
                        </button>
                    )}
                    {showDesc && (
                        <div className="temp-card-form-row">
                            <label>Description</label>
                            <textarea
                                value={tempDesc}
                                onChange={e => setTempDesc(e.target.value)}
                                className="temp-card-textarea"
                                rows={2}
                                placeholder="Card text (optional)"
                            />
                        </div>
                    )}
                    <div className="temp-card-form-actions">
                        <button className="btn btn-primary btn-sm" onClick={handleTempSubmit} disabled={!tempName.trim()}>
                            Add to Hand
                        </button>
                        <button className="btn btn-secondary btn-sm" onClick={cancelTempForm}>
                            Cancel
                        </button>
                    </div>
                </div>
            )}
            {children}
        </div>
    );
}

// ─── ScreenshotInput Component ───────────────────────────────────────
// Compact inline version — sits below the search input inside .search-section
function ScreenshotInput({ onImageCaptured, processing, disabled }) {
    const [dragOver, setDragOver] = useState(false);
    const fileInputRef = useRef(null);

    // Clipboard paste listener
    useEffect(() => {
        if (disabled) return;
        const handlePaste = (e) => {
            const items = Array.from(e.clipboardData?.items || []);
            const imageItem = items.find(item => item.type.startsWith('image/'));
            if (!imageItem) return;
            e.preventDefault();
            const blob = imageItem.getAsFile();
            if (blob.size > 10 * 1024 * 1024) {
                alert('Image too large (max 10MB). Please use a smaller screenshot.');
                return;
            }
            onImageCaptured(blob);
        };
        document.addEventListener('paste', handlePaste);
        return () => document.removeEventListener('paste', handlePaste);
    }, [onImageCaptured, disabled]);

    const handleDrop = (e) => {
        e.preventDefault();
        setDragOver(false);
        if (disabled || processing) return;
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) {
            if (file.size > 10 * 1024 * 1024) {
                alert('Image too large (max 10MB).');
                return;
            }
            onImageCaptured(file);
        }
    };

    const handleDragOver = (e) => { e.preventDefault(); setDragOver(true); };
    const handleDragLeave = () => setDragOver(false);

    const handleFileSelect = (e) => {
        const file = e.target.files[0];
        if (file && file.type.startsWith('image/')) {
            if (file.size > 10 * 1024 * 1024) {
                alert('Image too large (max 10MB).');
                return;
            }
            onImageCaptured(file);
        }
        e.target.value = '';
    };

    if (disabled) return null;

    return (
        <div
            className={`screenshot-paste-hint${dragOver ? ' dragover' : ''}${processing ? ' processing' : ''}`}
            onDrop={handleDrop}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
        >
            {processing ? (
                <span className="screenshot-hint-text processing">Analyzing screenshot...</span>
            ) : (
                <span className="screenshot-hint-text">
                    or paste a BGA screenshot (⌘V) or <button type="button" className="screenshot-upload-link" onClick={() => fileInputRef.current?.click()}>upload image</button>
                </span>
            )}
            <input
                ref={fileInputRef}
                type="file"
                accept="image/*"
                style={{ display: 'none' }}
                onChange={handleFileSelect}
            />
        </div>
    );
}

// ─── ScreenshotResults Component ────────────────────────────────────
function ScreenshotResults({ results, error, onDismiss, onAddTempCard }) {
    const [addedTemp, setAddedTemp] = useState(new Set());

    // Auto-dismiss success banners after 10s (unless there are warnings)
    useEffect(() => {
        if (!results || error) return;
        const hasWarnings = (results.unmatched && results.unmatched.length > 0) ||
                            (results.skippedOverflow && results.skippedOverflow.length > 0);
        if (hasWarnings) return;
        const timer = setTimeout(onDismiss, 10000);
        return () => clearTimeout(timer);
    }, [results, error, onDismiss]);

    // Reset addedTemp when results change
    useEffect(() => { setAddedTemp(new Set()); }, [results]);

    if (!results && !error) return null;

    if (error) {
        return (
            <div className="screenshot-banner screenshot-error">
                <span>{error}</span>
                <button className="screenshot-dismiss" onClick={onDismiss}>✕</button>
            </div>
        );
    }

    const parts = [];
    if (results.added > 0) parts.push(`Added ${results.added} card${results.added !== 1 ? 's' : ''}`);
    if (results.duplicates > 0) parts.push(`${results.duplicates} duplicate${results.duplicates !== 1 ? 's' : ''} skipped`);
    if (results.skippedOverflow && results.skippedOverflow.length > 0) {
        parts.push(`${results.skippedOverflow.length} skipped (slots full)`);
    }
    if (results.unmatched && results.unmatched.length > 0) {
        parts.push(`${results.unmatched.length} not recognized`);
    }
    if (parts.length === 0 && (!results.unmatched || results.unmatched.length === 0)) {
        parts.push('No card names found. Make sure card titles are visible in the screenshot');
    }

    const hasWarnings = (results.unmatched && results.unmatched.length > 0) ||
                        (results.skippedOverflow && results.skippedOverflow.length > 0) ||
                        results.added === 0;

    const handleAddTemp = (name, type) => {
        if (onAddTempCard) {
            onAddTempCard(name, type, '');
            setAddedTemp(prev => new Set([...prev, name]));
        }
    };

    const unmatchedToShow = (results.unmatched || []).filter(n => !addedTemp.has(n));

    return (
        <div className={`screenshot-banner ${hasWarnings ? 'screenshot-warning' : 'screenshot-success'}`}>
            <div>
                <span>{parts.join('. ')}.</span>
                {unmatchedToShow.length > 0 && onAddTempCard && (
                    <div className="screenshot-unmatched">
                        {unmatchedToShow.map(name => (
                            <div key={name} className="unmatched-row">
                                <span className="unmatched-name">{name}</span>
                                <button className="unmatched-add-btn" onClick={() => handleAddTemp(name, 'Occupation')}>+ Occ</button>
                                <button className="unmatched-add-btn" onClick={() => handleAddTemp(name, 'Minor Improvement')}>+ Minor</button>
                            </div>
                        ))}
                    </div>
                )}
                {unmatchedToShow.length > 0 && !onAddTempCard && (
                    <div className="screenshot-unmatched">
                        Not recognized: {unmatchedToShow.join(', ')}
                    </div>
                )}
                {addedTemp.size > 0 && (
                    <div className="screenshot-unmatched" style={{ opacity: 0.6 }}>
                        Added as temp: {[...addedTemp].join(', ')}
                    </div>
                )}
                {results.skippedOverflow && results.skippedOverflow.length > 0 && (
                    <div className="screenshot-unmatched">
                        Slots full: {results.skippedOverflow.join(', ')}
                    </div>
                )}
            </div>
            <button className="screenshot-dismiss" onClick={onDismiss}>✕</button>
        </div>
    );
}

// ─── TagPills Component ─────────────────────────────────────────────
function TagPills({ tags, abbreviated = true }) {
    if (!tags || tags.length === 0) return null;
    return (
        <span className="tag-pills">
            {tags.map(tag => {
                const def = TAG_DEFINITIONS[tag];
                return def ? (
                    <span key={tag} className="tag-pill" style={{ background: def.color }} title={tag}>
                        {abbreviated ? def.abbrev : tag}
                    </span>
                ) : null;
            })}
        </span>
    );
}

// ─── HandColumn Component ───────────────────────────────────────────
function HandColumn({ title, cards, expectedCount, sortKey, onRemoveCard, onSelectCard, selectedCardName, showRemove, fadedCardNames, onToggleFaded, highlightedCardNames, suggestions, expandedSuggestion, onToggleSuggestion, onEditTempCard }) {
    const count = cards.length;
    const fadedSet = useMemo(() => new Set(fadedCardNames || []), [fadedCardNames]);
    const highlightedSet = useMemo(() => new Set(highlightedCardNames || []), [highlightedCardNames]);
    const availableCount = highlightedCardNames ? highlightedSet.size : cards.filter(c => !fadedSet.has(c.name)).length;

    // Build suggestion lookup: card_name -> { rank_number, rationale }
    const suggestionMap = useMemo(() => {
        const map = {};
        if (suggestions) {
            suggestions.forEach(s => { map[s.card_name] = s; });
        }
        return map;
    }, [suggestions]);

    const sortOption = SORT_OPTIONS.find(s => s.key === sortKey) || SORT_OPTIONS[0];
    const sortedCards = useMemo(() => {
        return [...cards].sort((a, b) => {
            // Temp cards always sort to bottom
            if (a.isTemporary && !b.isTemporary) return 1;
            if (!a.isTemporary && b.isTemporary) return -1;
            const aVal = sortOption.getValue(a);
            const bVal = sortOption.getValue(b);
            if (aVal < bVal) return sortOption.ascending ? -1 : 1;
            if (aVal > bVal) return sortOption.ascending ? 1 : -1;
            return 0;
        });
    }, [cards, sortOption]);

    return (
        <div className="hand-column">
            <div className="column-header">
                <span>{title}</span>
                <span className={`card-count${count === expectedCount ? ' complete' : ''}`}>
                    {fadedCardNames || highlightedCardNames ? `${availableCount} avail` : `${count}/${expectedCount}`}
                </span>
            </div>
            <div className="card-list">
                {sortedCards.length === 0 && (
                    <div className="empty-hand" style={{ padding: '12px', fontSize: '0.85em' }}>
                        No cards added yet
                    </div>
                )}
                {sortedCards.map(card => {
                    const isSelected = card.name === selectedCardName;
                    const isFaded = fadedSet.has(card.name);
                    const isHighlighted = highlightedSet.has(card.name);
                    const suggestion = suggestionMap[card.name];
                    const isExpanded = expandedSuggestion === card.name;
                    const isTemp = card.isTemporary;
                    const handleClick = () => {
                        if (onToggleFaded) {
                            onToggleFaded(card.name);
                        } else if (onSelectCard && !isFaded) {
                            onSelectCard(card.name);
                        }
                    };
                    return (
                        <React.Fragment key={card.name}>
                            <div
                                className={`card-row${isSelected ? ' selected' : ''}${isFaded ? ' faded' : ''}${isHighlighted ? ' marked-remaining' : ''}${suggestion ? ' has-suggestion' : ''}${isTemp ? ' temp' : ''}`}
                                onClick={handleClick}
                            >
                                {suggestion && (
                                    <span
                                        className="ai-suggestion-pill"
                                        title="AI suggestion — click for rationale"
                                        onClick={(e) => { e.stopPropagation(); onToggleSuggestion && onToggleSuggestion(card.name); }}
                                    >
                                        {suggestion.rank_number}
                                    </span>
                                )}
                                {isTemp && <span className="temp-badge">NEW</span>}
                                <span className="card-name">{card.name}</span>
                                {!isTemp && <TagPills tags={card.tags} />}
                                <div className="card-stat">
                                    <div className="card-stat-label">Rank</div>
                                    <div>{isTemp ? '—' : `#${card.rank}`}</div>
                                </div>
                                <div className="card-stat">
                                    <div className="card-stat-label">ADP</div>
                                    <div>{isTemp ? '—' : card.adp}</div>
                                </div>
                                <div className="card-stat">
                                    <div className="card-stat-label">Elo/Play</div>
                                    <div>{isTemp ? '—' : (card.elo_per_play || '—')}</div>
                                </div>
                                <div className="card-stat">
                                    <div className="card-stat-label">Value</div>
                                    <div>{isTemp ? '—' : (card.value ? parseFloat(card.value).toFixed(1) : '—')}</div>
                                </div>
                                {isTemp && onEditTempCard && (
                                    <button
                                        className="edit-temp-btn"
                                        onClick={(e) => { e.stopPropagation(); onEditTempCard(card); }}
                                        title="Edit temporary card"
                                    >
                                        ✎
                                    </button>
                                )}
                                {showRemove && (
                                    <button
                                        className="remove-btn"
                                        onClick={(e) => { e.stopPropagation(); onRemoveCard(card.name); }}
                                        title="Remove card"
                                    >
                                        ✕
                                    </button>
                                )}
                            </div>
                            {suggestion && isExpanded && (
                                <div className="ai-rationale">
                                    {suggestion.rationale}
                                </div>
                            )}
                        </React.Fragment>
                    );
                })}
            </div>
        </div>
    );
}

// ─── PriorHands Component ───────────────────────────────────────────
function PriorHands({ hands, draftedCards, cardMap, currentRound, othersDrafted, onCardClick }) {
    const othersDraftedSet = new Set(othersDrafted || []);

    // Determine which hand groups have at least one completed pass
    const visibleHandGroups = HAND_GROUPS.filter(hg =>
        hands[hg.pass1Round] || (hg.pass2Round && hands[hg.pass2Round])
    );
    if (visibleHandGroups.length === 0) return null;

    const renderMiniCard = (name, round) => {
        const drafted = draftedCards[round] || {};
        const draftedSet = new Set([drafted.occupation, drafted.minor].filter(Boolean));
        const isDrafted = draftedSet.has(name);
        const isOthersTook = othersDraftedSet.has(name);
        const passNum = isDrafted ? getPassNumber(round) : null;
        const card = cardMap[name];
        const tagDots = (card?.tags || []).map(tag => {
            const def = TAG_DEFINITIONS[tag];
            return def ? (
                <span key={tag} className="mini-tag-dot" style={{ background: def.color }} title={tag}>{'\u200B'}</span>
            ) : null;
        }).filter(Boolean);

        return (
            <div
                key={name}
                className={`mini-card ${isDrafted ? 'drafted' : isOthersTook ? 'others-took' : 'passed'} clickable`}
                onClick={(e) => onCardClick && onCardClick(name, e)}
            >
                {passNum ? <span className="pick-badge">{passNum}</span> : isOthersTook ? '✗ ' : ''}
                {tagDots.length > 0 && <span className="mini-tag-dots">{tagDots}</span>}
                {name}
            </div>
        );
    };

    return (
        <div className="prior-hands-section">
            <div className="prior-hands-title">Prior Hands</div>
            <div className="tag-legend">
                {Object.entries(TAG_DEFINITIONS).map(([name, def]) => (
                    <span key={name} className="tag-legend-item">
                        <span className="tag-legend-dot" style={{ background: def.color }}>{'\u200B'}</span>
                        <span className="tag-legend-label">{name}</span>
                    </span>
                ))}
            </div>
            <div className="prior-hands-grid">
                {visibleHandGroups.map(({ handNum, pass1Round, pass2Round }) => {
                    const pass1Hand = hands[pass1Round] || [];
                    const pass1Drafted = draftedCards[pass1Round] || {};
                    const pass1DraftedSet = new Set([pass1Drafted.occupation, pass1Drafted.minor].filter(Boolean));
                    const hasPass1 = !!hands[pass1Round];

                    const pass2Hand = pass2Round ? (hands[pass2Round] || []) : [];
                    const pass2Drafted = pass2Round ? (draftedCards[pass2Round] || {}) : {};
                    const pass2DraftedSet = new Set([pass2Drafted.occupation, pass2Drafted.minor].filter(Boolean));
                    const hasPass2 = pass2Round && !!hands[pass2Round];

                    // Pass 1 drafted cards (occ + minor)
                    const pass1OccPick = pass1Drafted.occupation;
                    const pass1MinPick = pass1Drafted.minor;

                    // Pass 2 drafted cards (occ + minor)
                    const pass2OccPick = hasPass2 ? pass2Drafted.occupation : null;
                    const pass2MinPick = hasPass2 ? pass2Drafted.minor : null;

                    // Others-took cards from returning hand
                    const othersTookCards = hasPass2
                        ? pass2Hand.filter(n => othersDraftedSet.has(n))
                        : [];

                    // Remaining passed cards: in pass1Hand, not drafted by anyone in either pass, not others-took
                    const allDraftedNames = new Set([
                        ...pass1DraftedSet,
                        ...pass2DraftedSet,
                        ...othersTookCards,
                    ]);

                    // Helper to get the round a card belongs to (for renderMiniCard styling)
                    const othersTookSet = new Set(othersTookCards);
                    const getRoundForCard = (name) => {
                        if (pass1DraftedSet.has(name)) return pass1Round;
                        if (pass2DraftedSet.has(name)) return pass2Round;
                        if (othersTookSet.has(name)) return pass2Round;
                        return pass1Round; // passed cards
                    };

                    // Build all cards for each column, sorted by rank
                    const byRank = (a, b) => (cardMap[a]?.rank || 999) - (cardMap[b]?.rank || 999);

                    const allOccs = [...new Set([
                        ...(hasPass1 && pass1OccPick ? [pass1OccPick] : []),
                        ...pass1Hand.filter(n => cardMap[n]?.type === 'Occupation' && !allDraftedNames.has(n)),
                        ...othersTookCards.filter(n => cardMap[n]?.type === 'Occupation'),
                        ...(hasPass2 && pass2OccPick ? [pass2OccPick] : []),
                    ])].sort(byRank);

                    const allMins = [...new Set([
                        ...(hasPass1 && pass1MinPick ? [pass1MinPick] : []),
                        ...pass1Hand.filter(n => cardMap[n]?.type === 'Minor Improvement' && !allDraftedNames.has(n)),
                        ...othersTookCards.filter(n => cardMap[n]?.type === 'Minor Improvement'),
                        ...(hasPass2 && pass2MinPick ? [pass2MinPick] : []),
                    ])].sort(byRank);

                    return (
                        <div key={handNum} className="prior-hand-card">
                            <div className="prior-hand-header">Hand {handNum}</div>
                            <div style={{ display: 'flex', gap: '12px' }}>
                                <div style={{ flex: 1, minWidth: 0, overflow: 'hidden' }}>
                                    <div style={{ fontSize: '0.75em', fontWeight: 600, color: '#888', marginBottom: '4px' }}>Minor</div>
                                    {allMins.map(name => renderMiniCard(name, getRoundForCard(name)))}
                                </div>
                                <div style={{ flex: 1, minWidth: 0, overflow: 'hidden' }}>
                                    <div style={{ fontSize: '0.75em', fontWeight: 600, color: '#888', marginBottom: '4px' }}>Occ</div>
                                    {allOccs.map(name => renderMiniCard(name, getRoundForCard(name)))}
                                </div>
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
}

// ─── YourHand Component ─────────────────────────────────────────────
// ─── FarmGrid Component ─────────────────────────────────────────────
const FARM_STATES = ['', 'H', 'F', 'P'];
const LOCKED_CELLS = [5, 10]; // row 1 col 0 and row 2 col 0 (zero-indexed, row-major)

function FarmGrid({ grid, onCellClick }) {
    return (
        <div className="farm-grid-section">
            <div className="strategy-section-label">Farm Layout</div>
            <div className="farm-grid">
                {grid.map((state, i) => {
                    const isLocked = LOCKED_CELLS.includes(i);
                    return (
                        <div
                            key={i}
                            className={`farm-cell${isLocked ? ' locked' : ''}`}
                            data-state={state}
                            onClick={() => !isLocked && onCellClick(i)}
                        >
                            {state || ''}
                        </div>
                    );
                })}
            </div>
        </div>
    );
}

// ─── StrategyDashboard Component ────────────────────────────────────
function StrategyDashboard({ strategyResult, strategyLoading, strategyError, strategyAvailable, hasCards, farmGrid, onFarmCellClick, strategyNotes, onNotesChange, onGetAdvice, onDismissError }) {
    const dims = strategyResult?.dimensions;
    const [showReasoning, setShowReasoning] = React.useState(false);

    const renderDimension = (label, key) => {
        const dim = dims?.[key];
        // Support both old format (string) and new format ({ rating, reason })
        const rating = typeof dim === 'object' ? dim?.rating : dim;
        const reason = typeof dim === 'object' ? dim?.reason : null;
        const cls = rating ? rating.replace(/ /g, '_') : 'placeholder';
        const display = rating ? rating.replace(/_/g, ' ') : '—';
        return (
            <div className="dimension-row" title={reason || ''}>
                <span className="dimension-label">{label}</span>
                <div className="dimension-value-group">
                    <span className={`dimension-value ${cls}`}>{display}</span>
                    {reason && <span className="dimension-reason">{reason}</span>}
                </div>
            </div>
        );
    };

    return (
        <div className="strategy-dashboard">
            <div className="strategy-dashboard-title">Strategy</div>

            {/* Overall Analysis */}
            <div className="strategy-section-label">Analysis</div>
            <div className={`strategy-analysis${strategyResult?.overall_analysis ? ' has-content' : ''}`}>
                {strategyLoading ? 'Analyzing your draft...' : (strategyResult?.overall_analysis || 'Click "Get AI Advice" to analyze your draft.')}
            </div>

            {/* Strategy Archetypes */}
            {strategyResult?.archetypes && strategyResult.archetypes.length > 0 && (
                <div className="archetype-section">
                    <div className="strategy-section-label">Strategy Direction</div>
                    <div className="archetype-badges">
                        {strategyResult.archetypes.map((arch, i) => (
                            <span key={i} className="archetype-badge">{arch}</span>
                        ))}
                    </div>
                </div>
            )}

            {/* Internal Reasoning (collapsible) */}
            {strategyResult?.reasoning && (
                <div className="reasoning-section">
                    <button
                        className="reasoning-toggle"
                        onClick={() => setShowReasoning(prev => !prev)}
                    >
                        {showReasoning ? '▾ Hide AI Reasoning' : '▸ Show AI Reasoning'}
                    </button>
                    {showReasoning && (
                        <div className="reasoning-content">
                            {strategyResult.reasoning}
                        </div>
                    )}
                </div>
            )}

            {/* Dimensions */}
            <div className="dimension-section">
                {renderDimension('Food', 'food')}
                {renderDimension('Growth', 'growth')}
                {renderDimension('Extra Actions', 'extra_actions')}
                {renderDimension('Point Ceiling', 'point_ceiling')}
                {renderDimension('Plow', 'plow')}
            </div>

            <hr className="strategy-divider" />

            {/* Farm Grid */}
            <FarmGrid grid={farmGrid} onCellClick={onFarmCellClick} />

            {/* Notes */}
            <div className="strategy-section-label">Notes</div>
            <textarea
                className="strategy-notes"
                rows={4}
                placeholder="Jot down strategy notes..."
                value={strategyNotes}
                onChange={(e) => onNotesChange(e.target.value)}
            />

            <hr className="strategy-divider" />

            {/* Risks */}
            <div className="strategy-section-label">Risks</div>
            <div className={`strategy-risks${strategyResult?.risks ? ' has-content' : ''}`}>
                {strategyResult?.risks || 'No risks identified yet.'}
            </div>

            {/* Error banner */}
            {strategyError && (
                <div className="screenshot-banner screenshot-error" style={{ marginBottom: 12 }}>
                    <span>{strategyError}</span>
                    <button className="screenshot-dismiss" onClick={onDismissError}>✕</button>
                </div>
            )}

            {/* Get AI Advice button */}
            <button
                className={`strategy-btn${strategyLoading ? ' loading' : ''}`}
                disabled={!strategyAvailable || strategyLoading || !hasCards}
                onClick={onGetAdvice}
            >
                {strategyLoading ? 'Analyzing...' : (!strategyAvailable ? 'AI Advice (unavailable)' : (!hasCards ? 'Add cards to get advice' : 'Get AI Advice'))}
            </button>
        </div>
    );
}

function YourHand({ draftedCards, cardMap, onCardClick }) {
    const allDrafted = [];
    Object.entries(draftedCards).forEach(([round, picks]) => {
        const passNum = getPassNumber(round);
        const handNum = getHandNumber(round);
        if (picks.occupation && cardMap[picks.occupation]) {
            allDrafted.push({ ...cardMap[picks.occupation], _round: parseInt(round), _passNum: passNum, _handNum: handNum });
        }
        if (picks.minor && cardMap[picks.minor]) {
            allDrafted.push({ ...cardMap[picks.minor], _round: parseInt(round), _passNum: passNum, _handNum: handNum });
        }
    });

    if (allDrafted.length === 0) return null;

    const draftedOccs = allDrafted.filter(c => c.type === 'Occupation').sort((a, b) => a.rank - b.rank);
    const draftedMins = allDrafted.filter(c => c.type === 'Minor Improvement').sort((a, b) => a.rank - b.rank);

    const renderDraftedCard = (card) => (
        <div key={card.name} className={`card-row clickable${card.isTemporary ? ' temp' : ''}`} onClick={(e) => onCardClick && onCardClick(card.name, e)}>
            {card.isTemporary && <span className="temp-badge">NEW</span>}
            <span className="card-name">{card.name}</span>
            {!card.isTemporary && <TagPills tags={card.tags} abbreviated={false} />}
            <div className="card-stat"><div className="card-stat-label">Rank</div><div>{card.isTemporary ? '—' : `#${card.rank}`}</div></div>
            <div className="card-stat"><div className="card-stat-label">ADP</div><div>{card.isTemporary ? '—' : card.adp}</div></div>
            <div className="card-stat"><div className="card-stat-label">Elo/Play</div><div>{card.isTemporary ? '—' : (card.elo_per_play || '—')}</div></div>
            <div className="card-stat"><div className="card-stat-label">H{card._handNum}</div><div style={{ color: '#8B6914' }}><span className="pick-badge">{card._passNum}</span></div></div>
        </div>
    );

    return (
        <div className="your-hand-section">
            <div className="your-hand-title">Your Drafted Cards ({draftedMins.length} minor, {draftedOccs.length} occ)</div>
            <div className="hand-columns">
                <div className="hand-column">
                    <div className="column-header"><span>Minor Improvements</span></div>
                    <div className="card-list">{draftedMins.map(renderDraftedCard)}</div>
                </div>
                <div className="hand-column">
                    <div className="column-header"><span>Occupations</span></div>
                    <div className="card-list">{draftedOccs.map(renderDraftedCard)}</div>
                </div>
            </div>
        </div>
    );
}

// ─── CardDetailPopover Component ─────────────────────────────────────
function CardDetailPopover({ card, anchorRect, onClose }) {
    const popoverRef = useRef(null);
    const [position, setPosition] = useState({ top: 0, left: 0 });

    useEffect(() => {
        if (!anchorRect || !popoverRef.current) return;
        const popover = popoverRef.current;
        const rect = popover.getBoundingClientRect();
        const viewportW = window.innerWidth;
        const viewportH = window.innerHeight;

        let top = anchorRect.top;
        let left = anchorRect.right + 8;

        if (left + rect.width > viewportW - 16) {
            left = anchorRect.left - rect.width - 8;
        }
        if (left < 16) {
            left = Math.max(16, (viewportW - rect.width) / 2);
        }
        if (top + rect.height > viewportH - 16) {
            top = viewportH - rect.height - 16;
        }
        if (top < 16) top = 16;

        setPosition({ top, left });
    }, [anchorRect]);

    useEffect(() => {
        const handleMouseDown = (e) => {
            if (popoverRef.current && !popoverRef.current.contains(e.target)) {
                onClose();
            }
        };
        const handleKeyDown = (e) => {
            if (e.key === 'Escape') onClose();
        };
        document.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('keydown', handleKeyDown);
        return () => {
            document.removeEventListener('mousedown', handleMouseDown);
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, [onClose]);

    const imagePath = getCardImagePath(card.name);

    return (
        <div
            ref={popoverRef}
            className="card-detail-popover"
            style={{ top: position.top, left: position.left }}
        >
            <button className="popover-close" onClick={onClose}>&times;</button>
            <div className="popover-header">
                <span className="popover-name">{card.name}</span>
                <span className="popover-rank">{card.isTemporary ? 'Temp' : `#${card.rank}`}</span>
            </div>
            <div className="popover-meta">
                {card.type && <span className="popover-tag">{card.type}</span>}
                {card.card_id && <span className="popover-tag">{card.card_id}</span>}
                {card.cost && <span className="popover-tag">Cost: {card.cost}</span>}
                {card.vps && <span className="popover-tag">VPs: {card.vps}</span>}
                {(card.tags || []).map(tag => {
                    const def = TAG_DEFINITIONS[tag];
                    return def ? (
                        <span key={tag} className="popover-tag" style={{ background: def.color, color: 'white' }}>
                            {tag}
                        </span>
                    ) : null;
                })}
            </div>
            {imagePath && (
                <div className="popover-image">
                    <img src={imagePath} alt={card.name} />
                </div>
            )}
            {card.prerequisites && (
                <div className="popover-prereqs">
                    <strong>Prerequisites:</strong> {card.prerequisites}
                </div>
            )}
            <div className="popover-description">
                {card.description || 'No description available'}
            </div>
            <div className="popover-stats">
                <div><span className="popover-stat-label">PWR</span> {card.pwr}</div>
                <div><span className="popover-stat-label">ADP</span> {card.adp}</div>
                <div><span className="popover-stat-label">Play Rate</span> {card.play_rate}</div>
                <div><span className="popover-stat-label">Elo/Play</span> {card.elo_per_play || '—'}</div>
                <div><span className="popover-stat-label">Value</span> {card.value ? parseFloat(card.value).toFixed(1) : '—'}</div>
                <div><span className="popover-stat-label">VWP</span> {card.value_when_played ? parseFloat(card.value_when_played).toFixed(1) : '—'}</div>
            </div>
        </div>
    );
}

// ─── SummaryView Component ──────────────────────────────────────────
function SummaryView({ draftedCards, cardMap, onNewDraft, hands, othersDrafted, onCardClick }) {
    const [showAllDrafted, setShowAllDrafted] = useState(false);

    const allDrafted = [];
    Object.entries(draftedCards).forEach(([round, picks]) => {
        const passNum = getPassNumber(round);
        const handNum = getHandNumber(round);
        if (picks.occupation && cardMap[picks.occupation]) {
            allDrafted.push({ ...cardMap[picks.occupation], _round: parseInt(round), _passNum: passNum, _handNum: handNum });
        }
        if (picks.minor && cardMap[picks.minor]) {
            allDrafted.push({ ...cardMap[picks.minor], _round: parseInt(round), _passNum: passNum, _handNum: handNum });
        }
    });

    const occs = allDrafted.filter(c => c.type === 'Occupation').sort((a, b) => a.rank - b.rank);
    const mins = allDrafted.filter(c => c.type === 'Minor Improvement').sort((a, b) => a.rank - b.rank);

    // Build all known drafted cards (user + others)
    const allKnownDrafted = useMemo(() => {
        const result = [];

        // User's drafted cards
        Object.entries(draftedCards).forEach(([round, picks]) => {
            const passNum = getPassNumber(round);
            const handNum = getHandNumber(round);
            if (picks.occupation && cardMap[picks.occupation]) {
                result.push({ ...cardMap[picks.occupation], _round: parseInt(round), _passNum: passNum, _handNum: handNum, _drafter: 'you' });
            }
            if (picks.minor && cardMap[picks.minor]) {
                result.push({ ...cardMap[picks.minor], _round: parseInt(round), _passNum: passNum, _handNum: handNum, _drafter: 'you' });
            }
        });

        // Others' drafted cards — find which hand they appeared in
        const othersDraftedSet = new Set(othersDrafted || []);
        if (othersDraftedSet.size > 0) {
            const seen = new Set();
            Object.entries(hands || {}).forEach(([round, handNames]) => {
                const roundNum = parseInt(round);
                const handNum = getHandNumber(roundNum);
                handNames.forEach(name => {
                    if (othersDraftedSet.has(name) && cardMap[name] && !seen.has(name)) {
                        seen.add(name);
                        result.push({
                            ...cardMap[name],
                            _round: roundNum,
                            _handNum: handNum,
                            _drafter: 'other',
                        });
                    }
                });
            });
        }

        result.sort((a, b) => a.rank - b.rank);
        return result;
    }, [draftedCards, cardMap, hands, othersDrafted]);

    const renderSummaryCard = (card) => (
        <div key={card.name} className="summary-card clickable" onClick={(e) => onCardClick && onCardClick(card.name, e)}>
            <div className="card-name">
                {card.isTemporary && <span className="temp-badge" style={{ marginRight: 6 }}>NEW</span>}
                {card.name} {!card.isTemporary && <TagPills tags={card.tags} abbreviated={false} />}
            </div>
            <div className="card-stats">
                <span>Rank {card.isTemporary ? '—' : `#${card.rank}`}</span>
                <span>ADP {card.isTemporary ? '—' : card.adp}</span>
                <span>Elo/Play {card.isTemporary ? '—' : (card.elo_per_play || '—')}</span>
                <span>Value {card.isTemporary ? '—' : (card.value ? parseFloat(card.value).toFixed(1) : '—')}</span>
                <span>Play Rate {card.isTemporary ? '—' : card.play_rate}</span>
            </div>
        </div>
    );

    const renderAllDraftedCard = (card) => (
        <div key={`${card.name}-${card._drafter}`} className={`summary-card clickable${card._drafter === 'other' ? ' others-pick' : ''}`} onClick={(e) => onCardClick && onCardClick(card.name, e)}>
            <div className="card-name">
                {card._drafter === 'other' && <span className="other-badge">Other</span>}
                {card.isTemporary && <span className="temp-badge" style={{ marginRight: 6 }}>NEW</span>}
                {card.name} {!card.isTemporary && <TagPills tags={card.tags} abbreviated={false} />}
            </div>
            <div className="card-stats">
                <span>Rank {card.isTemporary ? '—' : `#${card.rank}`}</span>
                <span>ADP {card.isTemporary ? '—' : card.adp}</span>
                <span>H{card._handNum}</span>
                {card._drafter === 'you' && <span>Pass {card._passNum}</span>}
            </div>
        </div>
    );

    const allKnownOccs = allKnownDrafted.filter(c => c.type === 'Occupation');
    const allKnownMins = allKnownDrafted.filter(c => c.type === 'Minor Improvement');

    return (
        <div className="summary-section">
            <div className="summary-title">
                {showAllDrafted ? 'All Known Drafted Cards' : 'Draft Complete — Your Final Hand'}
            </div>
            <div className="summary-toggle">
                <button
                    className={`toggle-btn${!showAllDrafted ? ' active' : ''}`}
                    onClick={() => setShowAllDrafted(false)}
                >
                    Your Hand
                </button>
                <button
                    className={`toggle-btn${showAllDrafted ? ' active' : ''}`}
                    onClick={() => setShowAllDrafted(true)}
                >
                    All Drafted ({allKnownDrafted.length})
                </button>
            </div>

            {!showAllDrafted ? (
                <div className="summary-columns">
                    <div>
                        <div className="summary-column-title">Minor Improvements ({mins.length}/7)</div>
                        {mins.map(renderSummaryCard)}
                    </div>
                    <div>
                        <div className="summary-column-title">Occupations ({occs.length}/7)</div>
                        {occs.map(renderSummaryCard)}
                    </div>
                </div>
            ) : (
                <div className="summary-columns">
                    <div>
                        <div className="summary-column-title">Minor Improvements ({allKnownMins.length})</div>
                        {allKnownMins.map(renderAllDraftedCard)}
                    </div>
                    <div>
                        <div className="summary-column-title">Occupations ({allKnownOccs.length})</div>
                        {allKnownOccs.map(renderAllDraftedCard)}
                    </div>
                </div>
            )}

            <div style={{ textAlign: 'center', marginTop: '24px' }}>
                <button className="btn btn-primary" onClick={onNewDraft} style={{ background: 'rgba(255,255,255,0.2)', fontSize: '1.1em' }}>
                    Start New Draft
                </button>
            </div>
        </div>
    );
}

// ─── DraftApp Component ─────────────────────────────────────────────
function DraftApp() {
    const [cards, setCards] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    // Draft state — all of these get persisted to localStorage
    const [currentRound, setCurrentRound] = useState(1);
    const [draftStarted, setDraftStarted] = useState(false);
    const [currentHandNames, setCurrentHandNames] = useState([]);
    const [hands, setHands] = useState({});
    const [draftedCards, setDraftedCards] = useState({});
    const [selectedOccupation, setSelectedOccupation] = useState(null);
    const [selectedMinor, setSelectedMinor] = useState(null);
    const [sortKey, setSortKey] = useState('rank');

    // Rounds 5-7: marking phase + others' drafted cards
    const [markingPhase, setMarkingPhase] = useState(false);
    const [othersDrafted, setOthersDrafted] = useState([]);
    const [markedRemaining, setMarkedRemaining] = useState(new Set());

    // Temporary cards (not in database)
    const [tempCards, setTempCards] = useState({});

    // Screenshot processing state
    const [ocrAvailable, setOcrAvailable] = useState(false);
    const [screenshotProcessing, setScreenshotProcessing] = useState(false);
    const [screenshotError, setScreenshotError] = useState(null);
    const [screenshotResults, setScreenshotResults] = useState(null);

    // Check OCR endpoint availability on mount
    useEffect(() => {
        if (typeof screenshotOCR !== 'undefined' && screenshotOCR.checkAvailability) {
            screenshotOCR.checkAvailability().then(setOcrAvailable);
        }
    }, []);

    // Check strategy endpoint availability on mount
    useEffect(() => {
        if (typeof strategyAdvisor !== 'undefined' && strategyAdvisor.checkAvailability) {
            strategyAdvisor.checkAvailability().then(setStrategyAvailable);
        }
    }, []);

    // Strategy dashboard state
    const INITIAL_FARM_GRID = () => {
        const grid = Array(15).fill('');
        grid[5] = 'H';   // row 1, col 0 (locked)
        grid[10] = 'H';  // row 2, col 0 (locked)
        return grid;
    };
    const [farmGrid, setFarmGrid] = useState(INITIAL_FARM_GRID);
    const [strategyNotes, setStrategyNotes] = useState('');
    const [strategyAvailable, setStrategyAvailable] = useState(false);
    const [strategyResult, setStrategyResult] = useState(null);
    const [strategyLoading, setStrategyLoading] = useState(false);
    const [strategyError, setStrategyError] = useState(null);
    const [expandedSuggestion, setExpandedSuggestion] = useState(null);

    const handleFarmCellClick = useCallback((index) => {
        setFarmGrid(prev => {
            const next = [...prev];
            const current = next[index];
            const stateIndex = FARM_STATES.indexOf(current);
            next[index] = FARM_STATES[(stateIndex + 1) % FARM_STATES.length];
            return next;
        });
    }, []);

    // Popover state for card detail
    const [popoverCard, setPopoverCard] = useState(null);
    const [popoverAnchor, setPopoverAnchor] = useState(null);

    // Track whether initial load from localStorage is done
    const [restoredFromStorage, setRestoredFromStorage] = useState(false);

    // Load card data
    useEffect(() => {
        fetch('data/agricola-cards.json')
            .then(res => {
                if (!res.ok) throw new Error('Failed to load card data');
                return res.json();
            })
            .then(rawData => {
                // Deduplicate cards by name (keep first/higher-ranked entry)
                const seen = new Set();
                const data = rawData.filter(c => {
                    if (seen.has(c.name)) return false;
                    seen.add(c.name);
                    return true;
                });
                setCards(data);

                // Restore saved state after cards are loaded
                const saved = loadSavedState();
                if (saved && saved.draftStarted) {
                    // Validate card names still exist in the database
                    const validNames = new Set(data.map(c => c.name));
                    const filterNames = (names) => (names || []).filter(n => validNames.has(n));

                    setCurrentRound(saved.currentRound || 1);
                    setDraftStarted(true);
                    setCurrentHandNames(filterNames(saved.currentHandNames));
                    setSortKey(saved.sortKey || 'rank');
                    setMarkingPhase(saved.markingPhase || false);
                    setMarkedRemaining(new Set(filterNames(saved.markedRemaining || [])));
                    setOthersDrafted(filterNames(saved.othersDrafted));
                    setSelectedOccupation(null);
                    setSelectedMinor(null);

                    // Restore hands object (filter each hand's card names)
                    const restoredHands = {};
                    if (saved.hands) {
                        Object.entries(saved.hands).forEach(([round, handNames]) => {
                            restoredHands[round] = filterNames(handNames);
                        });
                    }
                    setHands(restoredHands);

                    // Restore draftedCards (validate names)
                    const restoredDrafted = {};
                    if (saved.draftedCards) {
                        Object.entries(saved.draftedCards).forEach(([round, picks]) => {
                            restoredDrafted[round] = {
                                occupation: picks.occupation && validNames.has(picks.occupation) ? picks.occupation : null,
                                minor: picks.minor && validNames.has(picks.minor) ? picks.minor : null,
                            };
                        });
                    }
                    setDraftedCards(restoredDrafted);

                    // Restore farm grid and notes
                    if (saved.farmGrid && Array.isArray(saved.farmGrid) && saved.farmGrid.length === 15) {
                        setFarmGrid(saved.farmGrid);
                    }
                    if (saved.strategyNotes) {
                        setStrategyNotes(saved.strategyNotes);
                    }
                }
                setRestoredFromStorage(true);
                setLoading(false);
            })
            .catch(err => {
                setError(err.message);
                setLoading(false);
            });
    }, []);

    // Save state to localStorage on changes (after initial restore)
    useEffect(() => {
        if (!restoredFromStorage) return;
        if (!draftStarted) {
            clearSavedState();
            return;
        }
        saveState({
            currentRound,
            draftStarted,
            currentHandNames,
            hands,
            draftedCards,
            sortKey,
            markingPhase,
            markedRemaining: [...markedRemaining],
            othersDrafted,
            farmGrid,
            strategyNotes,
        });
    }, [restoredFromStorage, currentRound, draftStarted, currentHandNames, hands, draftedCards, sortKey, markingPhase, markedRemaining, othersDrafted, farmGrid, strategyNotes]);

    // Random icon for title
    const [titleIcon] = useState(() => {
        const icons = [
            'Icons/Grain.webp', 'Icons/Wood.png', 'Icons/Clay.png',
            'Icons/Reed.webp', 'Icons/Stone.png', 'Icons/Sheep.webp',
            'Icons/Cow.webp', 'Icons/Pig.webp', 'Icons/Veg.webp',
            'Icons/Cornucopia.webp'
        ];
        return icons[Math.floor(Math.random() * icons.length)];
    });

    // Card lookup map (includes temp cards)
    const cardMap = useMemo(() => {
        const map = {};
        cards.forEach(c => { map[c.name] = c; });
        Object.values(tempCards).forEach(c => { map[c.name] = c; });
        return map;
    }, [cards, tempCards]);

    // Is this a returning-hand round?
    const isReturningRound = currentRound >= 5 && currentRound <= 7;

    // Current hand card objects split by type
    const currentHandCards = useMemo(() => {
        return currentHandNames.map(name => cardMap[name]).filter(Boolean);
    }, [currentHandNames, cardMap]);

    const occupations = useMemo(() =>
        currentHandCards.filter(c => c.type === 'Occupation'), [currentHandCards]);
    const minors = useMemo(() =>
        currentHandCards.filter(c => c.type === 'Minor Improvement'), [currentHandCards]);

    // Set of all card names used across all rounds (to prevent duplicates in search)
    const allUsedCardNames = useMemo(() => {
        const names = new Set(currentHandNames);
        Object.values(hands).forEach(handNames => {
            handNames.forEach(n => names.add(n));
        });
        return names;
    }, [currentHandNames, hands]);

    const expectedHandSize = HAND_SIZE_BY_ROUND[currentRound] || 10;

    // For returning rounds, hand is "full" once auto-populated (no manual entry needed)
    const handIsFull = isReturningRound
        ? currentHandNames.length > 0  // returning hands are pre-populated
        : (occupations.length === expectedHandSize && minors.length === expectedHandSize);

    // For draft selection: filter out faded cards
    const othersDraftedSet = useMemo(() => new Set(othersDrafted), [othersDrafted]);
    const availableOccs = useMemo(() => occupations.filter(c => !othersDraftedSet.has(c.name)), [occupations, othersDraftedSet]);
    const availableMins = useMemo(() => minors.filter(c => !othersDraftedSet.has(c.name)), [minors, othersDraftedSet]);

    const canConfirm = !markingPhase && selectedOccupation && selectedMinor;

    // Can get AI advice if there are cards in the current hand OR previously drafted cards
    const hasCardsForAdvice = currentHandNames.length > 0 || Object.values(draftedCards).some(p => p.occupation || p.minor);

    // ─── Auto-populate returning hands ─────────────────────────────
    useEffect(() => {
        if (!draftStarted || !isReturningRound || currentHandNames.length > 0) return;
        const sourceRound = RETURNING_HAND_SOURCE[currentRound];
        if (!sourceRound || !hands[sourceRound]) return;

        const sourceHand = hands[sourceRound];
        const sourceDrafted = draftedCards[sourceRound] || {};
        const userDraftedFromSource = new Set([sourceDrafted.occupation, sourceDrafted.minor].filter(Boolean));

        // Return all cards from the source hand except what the user drafted in that round
        const returningCards = sourceHand.filter(name => !userDraftedFromSource.has(name));
        setCurrentHandNames(returningCards);
        setMarkedRemaining(new Set());
        setMarkingPhase(true);
    }, [currentRound, draftStarted, isReturningRound, currentHandNames.length, hands, draftedCards]);

    // ─── Handlers ──────────────────────────────────────────────────
    const handleNewDraft = () => {
        setCurrentRound(1);
        setCurrentHandNames([]);
        setHands({});
        setDraftedCards({});
        setSelectedOccupation(null);
        setSelectedMinor(null);
        setSortKey('rank');
        setMarkingPhase(false);
        setOthersDrafted([]);
        setTempCards({});
        setFarmGrid(INITIAL_FARM_GRID());
        setStrategyNotes('');
        setStrategyResult(null);
        setStrategyError(null);
        setDraftStarted(true);
    };

    const handleResetDraft = () => {
        if (draftStarted && !window.confirm('Reset the current draft? All progress will be lost.')) return;
        setCurrentRound(1);
        setCurrentHandNames([]);
        setHands({});
        setDraftedCards({});
        setSelectedOccupation(null);
        setSelectedMinor(null);
        setSortKey('rank');
        setMarkingPhase(false);
        setOthersDrafted([]);
        setTempCards({});
        setFarmGrid(INITIAL_FARM_GRID());
        setStrategyNotes('');
        setStrategyResult(null);
        setStrategyError(null);
        setDraftStarted(false);
        clearSavedState();
    };

    const addTempCard = useCallback((name, type, description) => {
        const card = {
            name, type, description: description || '',
            isTemporary: true, rank: Infinity,
            pwr: '—', adp: '—', elo_per_play: '—',
            play_rate: '—', value: '—', value_when_played: '—',
            tags: [],
        };
        setTempCards(prev => ({ ...prev, [name]: card }));
        setCurrentHandNames(prev => {
            if (prev.includes(name)) return prev;
            const limit = HAND_SIZE_BY_ROUND[currentRound] || 10;
            const typeCount = prev.map(n => cardMap[n]).filter(c => c && c.type === type).length;
            if (typeCount >= limit) return prev;
            return [...prev, name];
        });
    }, [cardMap, currentRound]);

    const editTempCard = useCallback((oldName, newName, description) => {
        setTempCards(prev => {
            const card = prev[oldName];
            if (!card) return prev;
            const updated = { ...prev };
            if (oldName !== newName) delete updated[oldName];
            updated[newName] = { ...card, name: newName, description: description || '' };
            return updated;
        });
        if (oldName !== newName) {
            setCurrentHandNames(prev => prev.map(n => n === oldName ? newName : n));
        }
    }, []);

    const handleAddCard = useCallback((card) => {
        setCurrentHandNames(prev => {
            if (prev.includes(card.name)) return prev;
            const currentCards = prev.map(n => cardMap[n]).filter(Boolean);
            const typeCount = currentCards.filter(c => c.type === card.type).length;
            if (typeCount >= (HAND_SIZE_BY_ROUND[currentRound] || 10)) return prev;
            return [...prev, card.name];
        });
    }, [cardMap, currentRound]);

    const handleRemoveCard = useCallback((cardName) => {
        setCurrentHandNames(prev => prev.filter(n => n !== cardName));
        if (cardName === selectedOccupation) setSelectedOccupation(null);
        if (cardName === selectedMinor) setSelectedMinor(null);
        setTempCards(prev => {
            if (!prev[cardName]) return prev;
            const updated = { ...prev };
            delete updated[cardName];
            return updated;
        });
    }, [selectedOccupation, selectedMinor]);

    // Batch add cards (used by screenshot processing)
    const handleAddCards = useCallback((cardNames) => {
        setCurrentHandNames(prev => {
            let updated = [...prev];
            const limit = HAND_SIZE_BY_ROUND[currentRound] || 10;
            cardNames.forEach(name => {
                if (updated.includes(name)) return;
                const card = cardMap[name];
                if (!card) return;
                const typeCount = updated.map(n => cardMap[n]).filter(c => c && c.type === card.type).length;
                if (typeCount >= limit) return;
                updated.push(name);
            });
            return updated;
        });
    }, [cardMap, currentRound]);

    // Screenshot processing handler
    const handleScreenshotProcess = useCallback(async (imageBlob) => {
        if (screenshotProcessing) return;
        setScreenshotProcessing(true);
        setScreenshotError(null);
        setScreenshotResults(null);

        try {
            if (typeof screenshotOCR === 'undefined') {
                throw new Error('Screenshot feature is not available.');
            }

            const result = await screenshotOCR.processImage(imageBlob, cards, cardMap, currentHandNames, allUsedCardNames, currentRound);

            if (isReturningRound && markingPhase) {
                // In returning rounds, "duplicates" = cards in hand that screenshot confirmed
                const confirmedRemaining = result.duplicates || [];
                const newlyMarked = confirmedRemaining.filter(name => !markedRemaining.has(name));
                if (newlyMarked.length > 0) {
                    setMarkedRemaining(prev => {
                        const next = new Set(prev);
                        newlyMarked.forEach(n => next.add(n));
                        return next;
                    });
                }
                setScreenshotResults({
                    added: newlyMarked.length,
                    duplicates: confirmedRemaining.length - newlyMarked.length,
                    unmatched: result.unmatched,
                    skippedOverflow: [],
                    total: result.total,
                });
            } else {
                // Rounds 1-4: add matched cards to hand
                if (result.matched.length > 0) {
                    handleAddCards(result.matched);
                }
                setScreenshotResults({
                    added: result.added.length,
                    duplicates: result.duplicates.length,
                    unmatched: result.unmatched,
                    skippedOverflow: result.skippedOverflow,
                    total: result.total,
                });
            }
        } catch (err) {
            console.error('Screenshot processing error:', err);
            if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
                setScreenshotError('Could not reach the server. Check your connection.');
            } else {
                setScreenshotError(err.message || 'Screenshot processing failed. Please try again.');
            }
        } finally {
            setScreenshotProcessing(false);
        }
    }, [screenshotProcessing, cards, cardMap, currentHandNames, allUsedCardNames, currentRound, handleAddCards, isReturningRound, markingPhase, markedRemaining]);

    // Strategy advisor handler
    const handleGetAdvice = useCallback(async () => {
        if (strategyLoading) return;

        // Gather all drafted card names
        const draftedNames = [];
        Object.values(draftedCards).forEach(picks => {
            if (picks.occupation) draftedNames.push(picks.occupation);
            if (picks.minor) draftedNames.push(picks.minor);
        });

        // If current hand is empty, fall back to drafted cards for analysis
        const handToSend = currentHandNames.length > 0 ? currentHandNames : draftedNames;
        if (handToSend.length === 0) return; // button should be disabled, but guard anyway

        setStrategyLoading(true);
        setStrategyError(null);

        try {
            const result = await strategyAdvisor.getAdvice(
                handToSend,
                draftedNames,
                othersDrafted,
                currentRound
            );
            setStrategyResult(result);
        } catch (err) {
            console.error('Strategy advice error:', err);
            if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
                setStrategyError('Could not reach the server. Check your connection.');
            } else {
                setStrategyError(err.message || 'Could not get strategy advice. Please try again.');
            }
        } finally {
            setStrategyLoading(false);
        }
    }, [strategyLoading, currentHandNames, draftedCards, othersDrafted, currentRound]);

    const handleToggleSuggestion = useCallback((cardName) => {
        setExpandedSuggestion(prev => prev === cardName ? null : cardName);
    }, []);

    // Temp card editing state
    const [editingTempCard, setEditingTempCard] = useState(null);

    const handleEditTempCard = useCallback((card) => {
        setEditingTempCard({ originalName: card.name, name: card.name, description: card.description || '' });
    }, []);

    const handleSaveEditTempCard = useCallback(() => {
        if (!editingTempCard || !editingTempCard.name.trim()) return;
        editTempCard(editingTempCard.originalName, editingTempCard.name.trim(), editingTempCard.description.trim());
        setEditingTempCard(null);
    }, [editingTempCard, editTempCard]);

    const handleSelectOccupation = useCallback((cardName) => {
        if (othersDraftedSet.has(cardName)) return;
        setSelectedOccupation(prev => prev === cardName ? null : cardName);
    }, [othersDraftedSet]);

    const handleSelectMinor = useCallback((cardName) => {
        if (othersDraftedSet.has(cardName)) return;
        setSelectedMinor(prev => prev === cardName ? null : cardName);
    }, [othersDraftedSet]);

    const handleToggleFaded = useCallback((cardName) => {
        setOthersDrafted(prev =>
            prev.includes(cardName)
                ? prev.filter(n => n !== cardName)
                : [...prev, cardName]
        );
    }, []);

    const handleToggleMarking = useCallback((cardName) => {
        setMarkedRemaining(prev => {
            const next = new Set(prev);
            if (next.has(cardName)) next.delete(cardName);
            else next.add(cardName);
            return next;
        });
    }, []);

    const handleMiniCardClick = useCallback((cardName, event) => {
        const card = cardMap[cardName];
        if (!card) return;
        const rect = event.currentTarget.getBoundingClientRect();
        setPopoverCard(card);
        setPopoverAnchor(rect);
    }, [cardMap]);

    const handlePopoverClose = useCallback(() => {
        setPopoverCard(null);
        setPopoverAnchor(null);
    }, []);

    const handleDoneMarking = useCallback(() => {
        // Compute which cards were taken by others (not marked as remaining)
        const takenByOthers = currentHandNames.filter(name => !markedRemaining.has(name));
        setOthersDrafted(prev => [...prev, ...takenByOthers]);
        setMarkedRemaining(new Set());
        setMarkingPhase(false);
        setSelectedOccupation(null);
        setSelectedMinor(null);
    }, [markedRemaining, currentHandNames]);

    const handleBackToMarking = useCallback(() => {
        // Re-enter marking: move this round's othersDrafted entries back to unmarked state
        // by removing current hand cards from othersDrafted and resetting markedRemaining
        const currentHandSet = new Set(currentHandNames);
        setOthersDrafted(prev => prev.filter(name => !currentHandSet.has(name)));
        setMarkedRemaining(new Set());
        setMarkingPhase(true);
        setSelectedOccupation(null);
        setSelectedMinor(null);
    }, [currentHandNames]);

    const handleConfirmDraft = useCallback(() => {
        if (!selectedOccupation || !selectedMinor) return;
        setHands(prev => ({ ...prev, [currentRound]: [...currentHandNames] }));
        setDraftedCards(prev => ({
            ...prev,
            [currentRound]: { occupation: selectedOccupation, minor: selectedMinor }
        }));
        setCurrentHandNames([]);
        setSelectedOccupation(null);
        setSelectedMinor(null);
        setMarkingPhase(false);
        setCurrentRound(prev => prev + 1);
    }, [selectedOccupation, selectedMinor, currentHandNames, currentRound]);

    const handleUndo = useCallback(() => {
        if (currentRound <= 1) return;
        const prevRound = currentRound - 1;
        setCurrentHandNames(hands[prevRound] || []);
        setHands(prev => { const next = { ...prev }; delete next[prevRound]; return next; });
        setDraftedCards(prev => { const next = { ...prev }; delete next[prevRound]; return next; });
        setSelectedOccupation(null);
        setSelectedMinor(null);
        // If undoing into a returning round, restore marking phase
        if (prevRound >= 5) {
            setMarkingPhase(false); // drop into draft mode since hand was already marked
        } else {
            setMarkingPhase(false);
        }
        setCurrentRound(prevRound);
    }, [currentRound, hands]);

    // ─── Render ────────────────────────────────────────────────────
    if (loading) return <div className="loading">Loading card data...</div>;
    if (error) return <div className="loading">Error: {error}</div>;

    const draftComplete = draftStarted && currentRound > 7;

    return (
        <div>
            <nav className="nav-bar">
                <a href="index.html" className="nav-link">Card Lookup</a>
                <a href="draft.html" className="nav-link active">Draft Tool</a>
            </nav>

            <div className="draft-container">
                {/* Header */}
                <div className="draft-header">
                    <h1 className="draft-title">
                        <img src={titleIcon} alt="" className="title-icon" />
                        Agricola Draft Tool
                    </h1>
                    <div className="draft-header-right">
                        {draftStarted && !draftComplete && (
                            <div className="round-indicator">
                                Round <span className="round-num">{currentRound}</span> of 7
                                {isReturningRound && <span style={{ fontSize: '0.75em', marginLeft: '6px', color: '#888' }}>(returning)</span>}
                            </div>
                        )}
                        {draftComplete && (
                            <div className="round-indicator" style={{ background: '#d4edda', color: '#155724' }}>
                                Draft Complete
                            </div>
                        )}
                        {!draftStarted ? (
                            <button className="btn btn-primary" onClick={handleNewDraft}>New Draft</button>
                        ) : (
                            <button className="btn btn-danger" onClick={handleResetDraft}>Reset Draft</button>
                        )}
                    </div>
                </div>

                {/* Welcome state */}
                {!draftStarted && (
                    <div className="hand-section">
                        <div className="empty-hand">
                            Click "New Draft" to begin. You'll enter your starting hand of 10 occupations and 10 minor improvements, then draft 7 of each across 7 rounds.
                        </div>
                    </div>
                )}

                {/* Active draft (including post-completion) */}
                {draftStarted && (
                    <div className="draft-wide-layout">
                        <div className="draft-main-col">
                            {/* Prior Hands */}
                            <PriorHands hands={hands} draftedCards={draftedCards} cardMap={cardMap} currentRound={currentRound} othersDrafted={othersDrafted} onCardClick={handleMiniCardClick} />

                            {/* Summary view (after completion) */}
                            {draftComplete && (
                                <SummaryView draftedCards={draftedCards} cardMap={cardMap} onNewDraft={handleNewDraft} hands={hands} othersDrafted={othersDrafted} onCardClick={handleMiniCardClick} />
                            )}

                            {/* Search + Screenshot (only for rounds 1-4 manual entry) */}
                            {!draftComplete && !isReturningRound && (
                                <CardSearch
                                    cards={cards}
                                    onAddCard={handleAddCard}
                                    onAddTempCard={addTempCard}
                                    allUsedCardNames={allUsedCardNames}
                                >
                                    {ocrAvailable && (
                                        <ScreenshotInput
                                            onImageCaptured={handleScreenshotProcess}
                                            processing={screenshotProcessing}
                                            disabled={handIsFull}
                                        />
                                    )}
                                    <ScreenshotResults
                                        results={screenshotResults}
                                        error={screenshotError}
                                        onDismiss={() => { setScreenshotResults(null); setScreenshotError(null); }}
                                        onAddTempCard={addTempCard}
                                    />
                                </CardSearch>
                            )}

                            {/* Marking phase banner (rounds 5-7) */}
                            {!draftComplete && isReturningRound && markingPhase && (
                                <React.Fragment>
                                    <div className="marking-banner">
                                        <div className="marking-banner-text">
                                            <strong>Marking Phase:</strong> Click the cards you still have in this returning hand, or paste a screenshot. Then click Done Marking.
                                        </div>
                                        <button className="btn btn-primary" onClick={handleDoneMarking}>
                                            Done Marking
                                        </button>
                                    </div>
                                    {ocrAvailable && (
                                        <div style={{ marginBottom: '12px' }}>
                                            <ScreenshotInput
                                                onImageCaptured={handleScreenshotProcess}
                                                processing={screenshotProcessing}
                                                disabled={false}
                                            />
                                            <ScreenshotResults
                                                results={screenshotResults}
                                                error={screenshotError}
                                                onDismiss={() => { setScreenshotResults(null); setScreenshotError(null); }}
                                                onAddTempCard={addTempCard}
                                            />
                                        </div>
                                    )}
                                </React.Fragment>
                            )}

                            {/* Back to marking button */}
                            {!draftComplete && isReturningRound && !markingPhase && (
                                <div className="marking-banner" style={{ background: '#d1ecf1', borderColor: '#bee5eb' }}>
                                    <div className="marking-banner-text" style={{ color: '#0c5460' }}>
                                        <strong>Draft Phase:</strong> Select 1 occupation and 1 minor improvement to draft.
                                    </div>
                                    <button className="btn btn-secondary" onClick={handleBackToMarking}>
                                        ← Back to Marking
                                    </button>
                                </div>
                            )}

                            {/* Current Hand (hidden after completion) */}
                            {!draftComplete && <div className="hand-section">
                                <div className="sort-controls">
                                    <span style={{ fontSize: '0.85em', color: '#888', marginRight: '4px' }}>Sort by:</span>
                                    {SORT_OPTIONS.map(opt => (
                                        <button
                                            key={opt.key}
                                            className={`sort-btn${sortKey === opt.key ? ' active' : ''}`}
                                            onClick={() => setSortKey(opt.key)}
                                        >
                                            {opt.label}
                                        </button>
                                    ))}
                                </div>

                                <div className="hand-columns">
                                    {(() => {
                                        // Show suggestions only during selection phase
                                        const showSuggestions = handIsFull && !markingPhase && strategyResult?.suggestions;
                                        const occSuggestions = showSuggestions
                                            ? strategyResult.suggestions.filter(s => {
                                                const card = cardMap[s.card_name];
                                                return card && card.type === 'Occupation';
                                            })
                                            : null;
                                        const minSuggestions = showSuggestions
                                            ? strategyResult.suggestions.filter(s => {
                                                const card = cardMap[s.card_name];
                                                return card && card.type === 'Minor Improvement';
                                            })
                                            : null;
                                        return (
                                            <>
                                                <HandColumn
                                                    title="Minor Improvements"
                                                    cards={minors}
                                                    expectedCount={expectedHandSize}
                                                    sortKey={sortKey}
                                                    onRemoveCard={handleRemoveCard}
                                                    onSelectCard={(!markingPhase && handIsFull) ? handleSelectMinor : null}
                                                    selectedCardName={!markingPhase ? selectedMinor : null}
                                                    showRemove={!isReturningRound && !handIsFull}
                                                    fadedCardNames={isReturningRound && !markingPhase ? othersDrafted : null}
                                                    onToggleFaded={markingPhase ? handleToggleMarking : null}
                                                    highlightedCardNames={markingPhase ? [...markedRemaining] : null}
                                                    suggestions={minSuggestions}
                                                    expandedSuggestion={expandedSuggestion}
                                                    onToggleSuggestion={handleToggleSuggestion}
                                                    onEditTempCard={handleEditTempCard}
                                                />
                                                <HandColumn
                                                    title="Occupations"
                                                    cards={occupations}
                                                    expectedCount={expectedHandSize}
                                                    sortKey={sortKey}
                                                    onRemoveCard={handleRemoveCard}
                                                    onSelectCard={(!markingPhase && handIsFull) ? handleSelectOccupation : null}
                                                    selectedCardName={!markingPhase ? selectedOccupation : null}
                                                    showRemove={!isReturningRound && !handIsFull}
                                                    fadedCardNames={isReturningRound && !markingPhase ? othersDrafted : null}
                                                    onToggleFaded={markingPhase ? handleToggleMarking : null}
                                                    highlightedCardNames={markingPhase ? [...markedRemaining] : null}
                                                    suggestions={occSuggestions}
                                                    expandedSuggestion={expandedSuggestion}
                                                    onToggleSuggestion={handleToggleSuggestion}
                                                    onEditTempCard={handleEditTempCard}
                                                />
                                            </>
                                        );
                                    })()}
                                </div>

                                {/* Draft action buttons */}
                                {!markingPhase && handIsFull && (
                                    <div className="draft-actions">
                                        {currentRound > 1 && (
                                            <button className="btn btn-secondary" onClick={handleUndo}>
                                                ← Undo Round {currentRound - 1}
                                            </button>
                                        )}
                                        <button
                                            className="btn btn-primary"
                                            disabled={!canConfirm}
                                            onClick={handleConfirmDraft}
                                        >
                                            {canConfirm
                                                ? `Confirm Draft — ${cardMap[selectedMinor]?.name} + ${cardMap[selectedOccupation]?.name}`
                                                : 'Select 1 Minor Improvement + 1 Occupation'}
                                        </button>
                                    </div>
                                )}

                                {!isReturningRound && !handIsFull && (
                                    <div className="draft-actions">
                                        {currentRound > 1 && (
                                            <button className="btn btn-secondary" onClick={handleUndo}>
                                                ← Undo Round {currentRound - 1}
                                            </button>
                                        )}
                                        <div style={{ fontSize: '0.9em', color: '#888', padding: '10px' }}>
                                            Add {expectedHandSize - minors.length} more minor improvement{expectedHandSize - minors.length !== 1 ? 's' : ''} and {expectedHandSize - occupations.length} more occupation{expectedHandSize - occupations.length !== 1 ? 's' : ''} to this hand
                                        </div>
                                    </div>
                                )}
                            </div>}

                            {/* Your Hand (drafted cards) */}
                            <YourHand draftedCards={draftedCards} cardMap={cardMap} onCardClick={handleMiniCardClick} />
                        </div>

                        {/* Strategy sidebar */}
                        <div className="draft-side-col">
                            <StrategyDashboard
                                strategyResult={strategyResult}
                                strategyLoading={strategyLoading}
                                strategyError={strategyError}
                                strategyAvailable={strategyAvailable}
                                hasCards={hasCardsForAdvice}
                                farmGrid={farmGrid}
                                onFarmCellClick={handleFarmCellClick}
                                strategyNotes={strategyNotes}
                                onNotesChange={setStrategyNotes}
                                onGetAdvice={handleGetAdvice}
                                onDismissError={() => setStrategyError(null)}
                            />
                        </div>
                    </div>
                )}
            </div>

            {/* Card Detail Popover */}
            {popoverCard && popoverAnchor && (
                <CardDetailPopover
                    card={popoverCard}
                    anchorRect={popoverAnchor}
                    onClose={handlePopoverClose}
                />
            )}

            {/* Edit Temp Card Modal */}
            {editingTempCard && (
                <div className="temp-edit-overlay" onClick={() => setEditingTempCard(null)}>
                    <div className="temp-edit-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="temp-edit-title">Edit Temporary Card</div>
                        <div className="temp-card-form-row">
                            <label>Name</label>
                            <input
                                type="text"
                                className="temp-card-input"
                                value={editingTempCard.name}
                                onChange={(e) => setEditingTempCard(prev => ({ ...prev, name: e.target.value }))}
                                autoFocus
                            />
                        </div>
                        <div className="temp-card-form-row">
                            <label>Description</label>
                            <textarea
                                className="temp-card-textarea"
                                rows={3}
                                value={editingTempCard.description}
                                onChange={(e) => setEditingTempCard(prev => ({ ...prev, description: e.target.value }))}
                                placeholder="Card text (optional)"
                            />
                        </div>
                        <div className="temp-card-form-actions">
                            <button className="btn btn-primary btn-sm" onClick={handleSaveEditTempCard} disabled={!editingTempCard.name.trim()}>
                                Save
                            </button>
                            <button className="btn btn-secondary btn-sm" onClick={() => setEditingTempCard(null)}>
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<DraftApp />);

// Set random favicon
const RESOURCE_ICONS = [
    'Icons/Grain.webp', 'Icons/Wood.png', 'Icons/Clay.png',
    'Icons/Reed.webp', 'Icons/Stone.png', 'Icons/Sheep.webp',
    'Icons/Cow.webp', 'Icons/Pig.webp', 'Icons/Veg.webp',
    'Icons/Cornucopia.webp'
];
const randomIcon = RESOURCE_ICONS[Math.floor(Math.random() * RESOURCE_ICONS.length)];
const favicon = document.querySelector('link[rel="icon"]');
favicon.href = randomIcon;
    </script>
</body>
</html>
